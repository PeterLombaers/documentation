---
# Copyright Yahoo. Licensed under the terms of the Apache 2.0 license. See LICENSE in the project root.
title: "Metrics and Health API reference"
redirect_from:
- /documentation/reference/metrics.html
---

<h2 id="aggregated-metrics">Aggregated metrics</h2>
<p>
    For most cases, metrics should be collected aggregated on an application-level through the
    <em><a href="#metrics-v2-values">/metrics/v2/values</a></em> API or at node-level through either the
    <em><a href="#metrics-v1-values">/metrics/v1/values</a></em> or
    <em><a href="#prometheus-v1-values">/prometheus/v1/values</a></em> API.
</p>

<h3 id="metrics-v2-values">/metrics/v2/values</h3>
<p>
  The API is found on all nodes running a Container node at <em>http://host:port/metrics/v2/values</em>
</p>
<p>
  Port is the same as the container's query/feed endpoint, default 8080.
</p>
<p>
  The Vespa container exposes a selected set of metrics for every service on all nodes for the application.
  The metrics API can, for example, be used to
  <a href="https://github.com/vespa-engine/metrics-emitter/tree/master/cloudwatch">
    pull Vespa metrics to Cloudwatch</a> using an AWS lambda function.
</p>
<p>
  The <a href="#metrics-v2-values">metrics API</a> exposes a
  <a href="https://github.com/DataDog/integrations-extras/blob/master/vespa/metadata.csv">selected
    set of metrics</a> for the whole application, or for a single node,
  to allow integration with graphing and alerting services.
</p>
<p>
  The response is a <code>nodes</code> list (see example output below),
  where each element represents a node in the application and contains:
</p>
<ul>
  <li>The node's <code>hostname</code>.</li>
  <li>The node's <code>role</code> in the Vespa application.</li>
  <li>A <code>node</code> element containing the node's system metrics, e.g. cpu usage.</li>
  <li>A <code>services</code> list containing metrics for the node's services.
    The format of this list is described <a href="#metrics-v1-values">below</a>.</li>
</ul>
<pre>
$ curl http://localhost:8080/metrics/v2/values
</pre>
<pre>{% highlight json %}
{
    "nodes": [
        {
            "hostname": "vespa-container",
            "role": "hosts/vespa-container",
            "services": [
                {
                    "name": "vespa.container",
                    "timestamp": 1634127924,
                    "status": {
                        "code": "up",
                        "description": "Data collected successfully"
                    },
                    "metrics": [
                        {
                            "values": {
                                "memory_virt": 3685253120,
                                "memory_rss": 1441259520,
                                "cpu": 29.1900152827305
                            },
                            "dimensions": {
                                "serviceId": "container"
                            }
                        },
                        {
                            "values": {
                                "jdisc.gc.ms.average": 0
                            },
                            "dimensions": {
                                "gcName": "G1OldGeneration",
                                "serviceId": "container"
                            }
                        },
{% endhighlight %}</pre>



<h3 id="prometheus-v1-values">/prometheus/v1/values</h3>
<p>
  Vespa provides a <em>node metrics API</em> on each <em>node</em> at <em>http://host:port/prometheus/v1/values</em>
</p>
<p>
  Port is the same as the container's query/feed endpoint, default 8080.
</p>
<p>
  The prometheus API on each node exposes metrics in a text based
  <a href="https://prometheus.io/docs/instrumenting/exposition_formats/">format</a> that can be
  scraped by <a href="https://prometheus.io/docs/introduction/overview/">Prometheus</a>.
  The metrics is the same as in <code><a href="#metrics-v2-values">/metrics/v2/values</a></code>.
  See <a href="../operations/monitoring.html">monitoring</a> for a Prometheus / Grafana example.
</p>



<h3 id="metrics-v1-values">/metrics/v1/values</h3>
<p>
  Vespa provides a <em>node metrics API</em> on each <em>node</em> at
  <em>http://host:19092/metrics/v1/values</em>
</p>
<p>
  This API can be used for monitoring, using products like
  <a href="../operations/monitoring.html#pulling-into-prometheus">Prometheus</a> and
  <a href="../operations/monitoring.html#pulling-into-datadog">DataDog</a>.
  The response contains a selected set of metrics from each service running on the node.
  The output is a list of <code>service</code> elements, with name, status and metrics for that service - example:
</p>
<pre>{% highlight json %}
{
    "services": [
        {
            "name": "vespa.logd",
            "timestamp": 1561469256,
            "status": {
                "code": "up",
                "description": "Data collected successfully"
            },
            "metrics": [
                {
                    "values": {
                        "memory_virt": 111796224,
                        "memory_rss": 14086144,
                        "cpu": 1.0631117111036
                    },
                    "dimensions": {
                        "metrictype": "system",
                        "instance": "logd",
                        "vespaVersion": "7.0.0"
                    }
                }
            ]
        },
        ....
    ]
}
{% endhighlight %}</pre>
<p>
  The status for each service is either <code>up</code>,
  <code>down</code> or (in rare cases) <code>unknown</code>.
  The <code>unknown</code> status is for example used if the service seems to be alive,
  but does not report any metrics.
</p>

<h3 id="customizing-metric-sets">Customizing Metric Sets</h3>
<p>
    The aggregation metrics APIs will all return metrics from the
    <a href="https://github.com/DataDog/integrations-extras/blob/master/vespa/metadata.csv">default</a> metric set.
    While this should cover the most basic operational Vespa metrics, the set of metrics returned
    can be customized through the <em><a href="services-admin.html#metrics">metrics</a></em> section in
    <em><a href="services.html">services.xml</a></em>. You can control the metric set by either including a pre-defined
    <em><a href="services-admin.html#metric-set">metric-set</a></em> or configure a specific
    <em><a href="services-admin.html#metric">metric</a></em>. The latter way is also how you include any
    <a href="#metrics-from-custom-components">metrics from custom components</a>.
</p>

<p>
    Vespa comes with two pre-defined metric sets:
</p>
<table class="table">
    <thead>
        <tr>
            <td>Metric set ID</td>
            <td>Description</td>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td>default</td>
            <td>
                The default <a href="https://github.com/DataDog/integrations-extras/blob/master/vespa/metadata.csv">set of metrics</a>
            </td>
        </tr>
        <tr>
            <td>vespa</td>
            <td>
                A <a href="https://github.com/vespa-engine/vespa/blob/master/config-model/src/main/java/com/yahoo/vespa/model/admin/monitoring/VespaMetricSet.java">comprehensive list of metrics</a>
                used to inspect low-level behavior of Vespa.<br/>
                <b>NOTE:</b>This is a comprehensive set with a lot of metrics. See paragraph on cost below.
            </td>
        </tr>
    </tbody>
</table>

<p>
    Since increasing the number of metrics returned by Vespa will increase both network data to transfer, computing
    resources required to process, and metrics storage cost, it is recommended to keep the set of metrics to what
    you need to monitor your application. Also note that when configuring your own metric set, you need to pass
    the ID of your <em><a href="services-admin.html#consumer">consumer</a></em> as GET parameter
    <em>?consumer=my-consumer</em> to the APIs above (e.g. <em>/metrics/v2/values?consumer=my-consumer</em>).
</p>

<p>
    Example:
</p>
<pre>&lt;metrics&gt;
    &lt;consumer id=&quot;my-consumer&quot;&gt;
        &lt;metric-set id=&quot;default&quot; /&gt;
        &lt;metric id=&quot;vds.idealstate.garbage_collection.documents_removed.count&quot; /&gt;
    &lt;/consumer&gt;
&lt;/metrics&gt;</pre>



<h2 id="jdisc-metrics-details">jdisc Metrics Details</h2>
<p>
    Many of the metrics relevant to monitor for your application are emitted from the
    <a href="../jdisc/index.html">jDisc container</a> since this is both the outward
    facing component and where any custom business logic is run. The sections below covers some of the specifics
    related to these metrics.
</p>

<h3 id="metrics-from-custom-components">Metrics from custom components</h3>
<ol>
  <li>
    Add a <a href="https://javadoc.io/doc/com.yahoo.vespa/container-core/latest/com/yahoo/metrics/simple/MetricReceiver.html">
    com.yahoo.metrics.simple.MetricReceiver</a>
    instance to the constructor of the component - it is injected by the container.
  </li>
  <li>
    Declare the <em>gauges</em> and <em>counters</em> using the <em>declare</em> methods on the metric receiver.
    Optionally set arbitrary metric dimensions to default values at declaration time - refer to the javadoc for details.
  </li>
  <li>
    Each time there is some data to measure,
    invoke the <em>sample</em> method on gauges or the <em>add</em> method on counters.
    When sampling data, any dimensions can optionally be set.
  </li>
</ol>
<p>
  The gauges and counters declared are inherently thread-safe. Example:
</p>
<pre>{% highlight java %}
package com.yahoo.example;

import java.util.Optional;
import com.yahoo.metrics.simple.Gauge;
import com.yahoo.metrics.simple.MetricSettings;
import com.yahoo.metrics.simple.MetricReceiver;
import com.yahoo.search.Query;
import com.yahoo.search.Result;
import com.yahoo.search.Searcher;
import com.yahoo.search.searchchain.Execution;

public class HitCountSearcher extends Searcher {
    private static final String LANGUAGE_DIMENSION_NAME = "query_language";
    private static final String EXAMPLE_METRIC_NAME = "example_hitcounts";
    private final Gauge hitCountMetric;

    public HitCountSearcher(MetricReceiver receiver) {
        this.hitCountMetric = receiver.declareGauge(EXAMPLE_METRIC_NAME, Optional.empty(),
                new MetricSettings.Builder().histogram(true).build());
    }

    @Override
    public Result search(Query query, Execution execution) {
        Result result = execution.search(query);
        hitCountMetric
            .sample(result.getTotalHitCount(),
                    hitCountMetric.builder()
                        .set(LANGUAGE_DIMENSION_NAME, query.getModel().getParsingLanguage().languageCode())
                        .build());
        return result;
    }
}
{% endhighlight %}</pre>
<p>
  Then look at the metrics where the new event <em>example_hitcounts</em> is available in the list of metrics.
  The histograms for the last five minutes of logged data are available as CSV per
  dimension at <em>http://host:port/state/v1/metrics/histograms</em>.
  In the example, that would include the estimated total hit counts for queries, grouped by language.
  The underlying implementation of the histograms is <a href="http://hdrhistogram.org/">HdrHistogram</a>,
  and the CSV is simply what that library generates itself.
</p>


<h3 id="container-metrics">Container Metrics</h3>
<p>
  A few metrics are emitted with under multiple names, for compatibility with different metrics frameworks.
</p>

<h4 id="generic-container-metrics">Generic Container Metrics</h4>
<p>
  These metrics are output for the server as a whole and are not specific to HTTP.
</p>
<table class="table">
  <thead>
  <tr>
    <th>Metric name</th><th>Description</th>
  </tr>
  </thead><tbody>
<tr>
  <td>serverStartedMillis</td>
  <td>Time since server started</td>
</tr><tr>
  <td>mem.heap.total</td>
  <td>Total heap size</td>
</tr><tr>
  <td>mem.heap.free</td>
  <td>Free heap size</td>
</tr><tr>
  <td>mem.heap.used</td>
  <td>Used heap size</td>
</tr>
</tbody>
</table>


<h4 id="thread-pool-metrics">Thread Pool Metrics</h4>
<p>
    Metrics for the container thread pools.
    The <code>jdisc.thread_pool.*</code> metrics have a dimension <code>threadpool</code> with thread pool name,
    e.g <em>default-pool</em> for the container's default thread pool.
    See <a href="../performance/container-tuning.html">Container Tuning</a> for details.
</p>
<table class="table">
    <thead>
    <tr><th>Metric name</th><th>Description</th></tr>
    </thead>
    <tbody>
    <tr>
        <td>jdisc.thread_pool.size</td>
        <td>Size of the thread pool</td>
    </tr><tr>
        <td>jdisc.thread_pool.active_threads</td>
        <td>Number of threads that are active</td>
    </tr><tr>
        <td>jdisc.thread_pool.max_allowed_size</td>
        <td>The maximum allowed number of threads in the pool</td>
    </tr><tr>
        <td>jdisc.thread_pool.rejected_tasks</td>
        <td>Number of tasks rejected by the thread pool</td>
    </tr><tr>
        <td>jdisc.thread_pool.unhandled_exceptions</td>
        <td>Number of exceptions thrown by tasks</td>
    </tr><tr>
        <td>jdisc.thread_pool.work_queue.capacity</td>
        <td>Capacity of the task queue</td>
    </tr><tr>
        <td>jdisc.thread_pool.work_queue.size</td>
        <td>Size of the task queue</td>
    </tr><tr>
        <td>jdisc.http.jetty.threadpool.thread.max</td>
        <td>Jetty thread pool: configured maximum number of threads</td>
    </tr><tr>
        <td>jdisc.http.jetty.threadpool.thread.min</td>
        <td>Jetty thread pool: configured minimum number of threads</td>
    </tr><tr>
        <td>jdisc.http.jetty.threadpool.thread.reserved</td>
        <td>Jetty thread pool: configured number of reserved threads or -1 for heuristic</td>
    </tr><tr>
        <td>jdisc.http.jetty.threadpool.thread.busy</td>
        <td>Jetty thread pool: number of threads executing internal and transient jobs</td>
    </tr><tr>
        <td>jdisc.http.jetty.threadpool.thread.total</td>
        <td>Jetty thread pool: current number of threads</td>
    </tr><tr>
        <td>jdisc.http.jetty.threadpool.queue.size</td>
        <td>Jetty thread pool: current size of the job queue</td>
    </tr>
    </tbody>
</table>


<h4 id="http-specific-metrics">HTTP Specific Metrics</h4>
<p>
    These are metrics specific for HTTP.
    Those metrics that are specific to a connector will have a dimension containing the TCP listen port.
</p>
<table class="table">
    <thead><tr><th>Metric name</th><th>Description</th></tr></thead>
        <tbody>
        <tr>
            <td>jdisc.http.requests.status</td>
            <td>Number of requests to the built-in status handler</td>
        </tr><tr>
            <td>http.status.1xx</td>
            <td>Number of responses with a 1xx status</td>
        </tr><tr>
            <td>http.status.2xx</td>
            <td>Number of responses with a 2xx status</td>
        </tr><tr>
            <td>http.status.3xx</td>
            <td>Number of responses with a 3xx status</td>
        </tr><tr>
            <td>http.status.4xx</td>
            <td>Number of responses with a 4xx status</td>
        </tr><tr>
            <td>http.status.5xx</td>
            <td>Number of responses with a 5xx status</td>
        </tr><tr>
            <td>serverNumConnections</td>
            <td>The total number of connections opened</td>
        </tr><tr>
            <td>serverNumOpenConnections</td>
            <td>The current number of open connections</td>
        </tr><tr>
            <td>serverConnectionsOpenMax</td>
            <td>The max number of open connections</td>
        </tr><tr>
            <td>serverConnectionDurationMean, -Max, -StdDev</td>
            <td>The mean/max/stddev of connection duration in ms</td>
        </tr><tr>
            <td>serverNumRequests, jdisc.http.requests</td>
            <td>Number of requests received by the connector</td>
        </tr><tr>
            <td>serverNumSuccessfulResponses</td>
            <td>Number of successful responses sent by the connector</td>
        </tr><tr>
            <td>serverNumFailedResponses</td>
            <td>Number of error responses sent by the connector</td>
        </tr><tr>
            <td>serverNumSuccessfulResponseWrites</td>
            <td>Number of HTTP response chunks that have been successfully written to the network.</td>
        </tr><tr>
            <td>serverNumFailedResponseWrites</td>
            <td>Number of HTTP response chunks that have not been successfully written to the network,
                due to some kind of I/O error.</td>
        </tr><tr>
            <td>serverBytesReceived</td>
            <td>Number of bytes the connector has received</td>
        </tr><tr>
            <td>serverBytesSent</td>
            <td>Number of bytes the connector has sent</td>
        </tr><tr>
            <td>serverTimeToFirstByte</td>
            <td>Time to first byte of response body is sent</td>
        </tr><tr>
            <td>serverTotalSuccessfulResponseLatency</td>
            <td>Time to complete successful responses</td>
        </tr><tr>
            <td>serverTotalFailedResponseLatency</td>
            <td>Time to complete failed responses</td>
        </tr>
    </tbody>
</table>
