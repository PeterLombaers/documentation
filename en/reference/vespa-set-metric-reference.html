---
# Copyright Yahoo. Licensed under the terms of the Apache 2.0 license. See LICENSE in the project root.
title: "Vespa Metric Set"
---


<h2 id=clustercontroller-metrics>Clustercontroller Metrics</h2>
<table class="table">
    <thead>
        <tr><th>Name</th><th>Description</th><th>Unit</th><th>Suffixes</th></tr>
    </thead>
    <tbody>
	<tr>
	  <td>cluster-controller.down.count</td>
	  <td>Number of content nodes down</td>
	  <td>node</td>
	  <td>last</td>
	</tr>
	<tr>
	  <td>cluster-controller.initializing.count</td>
	  <td>Number of content nodes initializing</td>
	  <td>node</td>
	  <td>last</td>
	</tr>
	<tr>
	  <td>cluster-controller.maintenance.count</td>
	  <td>Number of content nodes in maintenance</td>
	  <td>node</td>
	  <td>last</td>
	</tr>
	<tr>
	  <td>cluster-controller.retired.count</td>
	  <td>Number of content nodes that are retired</td>
	  <td>node</td>
	  <td>last</td>
	</tr>
	<tr>
	  <td>cluster-controller.stopping.count</td>
	  <td>Number of content nodes currently stopping</td>
	  <td>node</td>
	  <td>last</td>
	</tr>
	<tr>
	  <td>cluster-controller.up.count</td>
	  <td>Number of content nodes up</td>
	  <td>node</td>
	  <td>last</td>
	</tr>
	<tr>
	  <td>cluster-controller.cluster-state-change.count</td>
	  <td>Number of nodes changing state</td>
	  <td>node</td>
	  <td>N/A</td>
	</tr>
	<tr>
	  <td>cluster-controller.busy-tick-time-ms</td>
	  <td>Time busy</td>
	  <td>millisecond</td>
	  <td>last, max, sum, count</td>
	</tr>
	<tr>
	  <td>cluster-controller.idle-tick-time-ms</td>
	  <td>Time idle</td>
	  <td>millisecond</td>
	  <td>last, max, sum, count</td>
	</tr>
	<tr>
	  <td>cluster-controller.work-ms</td>
	  <td>Time used for actual work</td>
	  <td>millisecond</td>
	  <td>last, sum, count</td>
	</tr>
	<tr>
	  <td>cluster-controller.is-master</td>
	  <td>1 if this cluster controller is currently the master, or 0 if not</td>
	  <td>binary</td>
	  <td>last</td>
	</tr>
	<tr>
	  <td>cluster-controller.remote-task-queue.size</td>
	  <td>Number of remote tasks queued</td>
	  <td>operation</td>
	  <td>last</td>
	</tr>
	<tr>
	  <td>cluster-controller.node-event.count</td>
	  <td>Number of node events</td>
	  <td>operation</td>
	  <td>N/A</td>
	</tr>
	<tr>
	  <td>cluster-controller.resource_usage.nodes_above_limit</td>
	  <td>The number of content nodes above resource limit, blocking feed</td>
	  <td>node</td>
	  <td>last, max</td>
	</tr>
	<tr>
	  <td>cluster-controller.resource_usage.max_memory_utilization</td>
	  <td>Current memory utilisation, per content node</td>
	  <td>fraction</td>
	  <td>last, max</td>
	</tr>
	<tr>
	  <td>cluster-controller.resource_usage.max_disk_utilization</td>
	  <td>Current disk space utilisation, per content node</td>
	  <td>fraction</td>
	  <td>last, max</td>
	</tr>
	<tr>
	  <td>cluster-controller.resource_usage.memory_limit</td>
	  <td>Disk space limit as a fraction of available disk space</td>
	  <td>fraction</td>
	  <td>last</td>
	</tr>
	<tr>
	  <td>cluster-controller.resource_usage.disk_limit</td>
	  <td>Memory space limit as a fraction of available memory</td>
	  <td>fraction</td>
	  <td>last</td>
	</tr>
	<tr>
	  <td>reindexing.progress</td>
	  <td>Re-indexing progress</td>
	  <td>fraction</td>
	  <td>last</td>
	</tr>
    </tbody>
</table>

<h2 id=configserver-metrics>Configserver Metrics</h2>
<table class="table">
    <thead>
        <tr><th>Name</th><th>Description</th><th>Unit</th><th>Suffixes</th></tr>
    </thead>
    <tbody>
	<tr>
	  <td>configserver.requests</td>
	  <td>Number of requests processed</td>
	  <td>request</td>
	  <td>count</td>
	</tr>
	<tr>
	  <td>configserver.failedRequests</td>
	  <td>Number of requests that failed</td>
	  <td>request</td>
	  <td>count</td>
	</tr>
	<tr>
	  <td>configserver.latency</td>
	  <td>Time to complete requests</td>
	  <td>millisecond</td>
	  <td>max, sum, count</td>
	</tr>
	<tr>
	  <td>configserver.cacheConfigElems</td>
	  <td>Time to complete requests</td>
	  <td>item</td>
	  <td>last</td>
	</tr>
	<tr>
	  <td>configserver.cacheChecksumElems</td>
	  <td>Number of checksum elements in the cache</td>
	  <td>item</td>
	  <td>last</td>
	</tr>
	<tr>
	  <td>configserver.hosts</td>
	  <td>The number of nodes being served configuration from the config server cluster</td>
	  <td>node</td>
	  <td>last</td>
	</tr>
	<tr>
	  <td>configserver.delayedResponses</td>
	  <td>Number of delayed responses</td>
	  <td>response</td>
	  <td>count</td>
	</tr>
	<tr>
	  <td>configserver.sessionChangeErrors</td>
	  <td>Number of session change errors</td>
	  <td>session</td>
	  <td>count</td>
	</tr>
	<tr>
	  <td>configserver.zkZNodes</td>
	  <td>Number of ZooKeeper nodes present</td>
	  <td>node</td>
	  <td>last</td>
	</tr>
	<tr>
	  <td>configserver.zkAvgLatency</td>
	  <td>Average latency for ZooKeeper requests</td>
	  <td>millisecond</td>
	  <td>last</td>
	</tr>
	<tr>
	  <td>configserver.zkMaxLatency</td>
	  <td>Max latency for ZooKeeper requests</td>
	  <td>millisecond</td>
	  <td>last</td>
	</tr>
	<tr>
	  <td>configserver.zkConnections</td>
	  <td>Number of ZooKeeper connections</td>
	  <td>connection</td>
	  <td>last</td>
	</tr>
	<tr>
	  <td>configserver.zkOutstandingRequests</td>
	  <td>Number of ZooKeeper requests in flight</td>
	  <td>request</td>
	  <td>last</td>
	</tr>
    </tbody>
</table>

<h2 id=container-metrics>Container Metrics</h2>
<table class="table">
    <thead>
        <tr><th>Name</th><th>Description</th><th>Unit</th><th>Suffixes</th></tr>
    </thead>
    <tbody>
	<tr>
	  <td>jrt.transport.tls-certificate-verification-failures</td>
	  <td>TLS certificate verification failures</td>
	  <td>failure</td>
	  <td>N/A</td>
	</tr>
	<tr>
	  <td>jrt.transport.peer-authorization-failures</td>
	  <td>TLS peer authorization failures</td>
	  <td>failure</td>
	  <td>N/A</td>
	</tr>
	<tr>
	  <td>jrt.transport.server.tls-connections-established</td>
	  <td>TLS server connections established</td>
	  <td>connection</td>
	  <td>N/A</td>
	</tr>
	<tr>
	  <td>jrt.transport.client.tls-connections-established</td>
	  <td>TLS client connections established</td>
	  <td>connection</td>
	  <td>N/A</td>
	</tr>
	<tr>
	  <td>jrt.transport.server.unencrypted-connections-established</td>
	  <td>Unencrypted server connections established</td>
	  <td>connection</td>
	  <td>N/A</td>
	</tr>
	<tr>
	  <td>jrt.transport.client.unencrypted-connections-established</td>
	  <td>Unencrypted client connections established</td>
	  <td>connection</td>
	  <td>N/A</td>
	</tr>
	<tr>
	  <td>application_generation</td>
	  <td>The currently live application config generation (aka session id)</td>
	  <td>version</td>
	  <td>N/A</td>
	</tr>
	<tr>
	  <td>handled.requests</td>
	  <td>The number of requests handled per metrics snapshot</td>
	  <td>operation</td>
	  <td>count</td>
	</tr>
	<tr>
	  <td>handled.latency</td>
	  <td>The time used for requests during this metrics snapshot</td>
	  <td>millisecond</td>
	  <td>sum, count, max</td>
	</tr>
	<tr>
	  <td>serverNumOpenConnections</td>
	  <td>The number of currently open connections</td>
	  <td>connection</td>
	  <td>max, last, average</td>
	</tr>
	<tr>
	  <td>serverNumConnections</td>
	  <td>The total number of connections opened</td>
	  <td>connection</td>
	  <td>max, last, average</td>
	</tr>
	<tr>
	  <td>serverBytesReceived</td>
	  <td>The number of bytes received by the server</td>
	  <td>byte</td>
	  <td>sum, count</td>
	</tr>
	<tr>
	  <td>serverBytesSent</td>
	  <td>The number of bytes sent from the server</td>
	  <td>byte</td>
	  <td>sum, count</td>
	</tr>
	<tr>
	  <td>jdisc.thread_pool.unhandled_exceptions</td>
	  <td>Number of exceptions thrown by tasks</td>
	  <td>thread</td>
	  <td>sum, count, last, min, max</td>
	</tr>
	<tr>
	  <td>jdisc.thread_pool.work_queue.capacity</td>
	  <td>Capacity of the task queue</td>
	  <td>thread</td>
	  <td>sum, count, last, min, max</td>
	</tr>
	<tr>
	  <td>jdisc.thread_pool.work_queue.size</td>
	  <td>Size of the task queue</td>
	  <td>thread</td>
	  <td>sum, count, last, min, max</td>
	</tr>
	<tr>
	  <td>jdisc.thread_pool.rejected_tasks</td>
	  <td>Number of tasks rejected by the thread pool</td>
	  <td>thread</td>
	  <td>sum, count, last, min, max</td>
	</tr>
	<tr>
	  <td>jdisc.thread_pool.size</td>
	  <td>Size of the thread pool</td>
	  <td>thread</td>
	  <td>sum, count, last, min, max</td>
	</tr>
	<tr>
	  <td>jdisc.thread_pool.max_allowed_size</td>
	  <td>The maximum allowed number of threads in the pool</td>
	  <td>thread</td>
	  <td>sum, count, last, min, max</td>
	</tr>
	<tr>
	  <td>jdisc.thread_pool.active_threads</td>
	  <td>Number of threads that are active</td>
	  <td>thread</td>
	  <td>sum, count, last, min, max</td>
	</tr>
	<tr>
	  <td>jdisc.http.jetty.threadpool.thread.max</td>
	  <td>Configured maximum number of threads</td>
	  <td>thread</td>
	  <td>sum, count, last, min, max</td>
	</tr>
	<tr>
	  <td>jdisc.http.jetty.threadpool.thread.min</td>
	  <td>Configured minimum number of threads</td>
	  <td>thread</td>
	  <td>sum, count, last, min, max</td>
	</tr>
	<tr>
	  <td>jdisc.http.jetty.threadpool.thread.reserved</td>
	  <td>Configured number of reserved threads or -1 for heuristic</td>
	  <td>thread</td>
	  <td>sum, count, last, min, max</td>
	</tr>
	<tr>
	  <td>jdisc.http.jetty.threadpool.thread.busy</td>
	  <td>Number of threads executing internal and transient jobs</td>
	  <td>thread</td>
	  <td>sum, count, last, min, max</td>
	</tr>
	<tr>
	  <td>jdisc.http.jetty.threadpool.thread.total</td>
	  <td>Current number of threads</td>
	  <td>thread</td>
	  <td>sum, count, last, min, max</td>
	</tr>
	<tr>
	  <td>jdisc.http.jetty.threadpool.queue.size</td>
	  <td>Current size of the job queue</td>
	  <td>thread</td>
	  <td>sum, count, last, min, max</td>
	</tr>
	<tr>
	  <td>httpapi_latency</td>
	  <td>Duration for requests to the HTTP document APIs</td>
	  <td>millisecond</td>
	  <td>max, sum, count</td>
	</tr>
	<tr>
	  <td>httpapi_pending</td>
	  <td>Document operations pending execution</td>
	  <td>operation</td>
	  <td>max, sum, count</td>
	</tr>
	<tr>
	  <td>httpapi_num_operations</td>
	  <td>Total number of document operations performed</td>
	  <td>operation</td>
	  <td>rate</td>
	</tr>
	<tr>
	  <td>httpapi_num_updates</td>
	  <td>Document update operations performed</td>
	  <td>operation</td>
	  <td>rate</td>
	</tr>
	<tr>
	  <td>httpapi_num_removes</td>
	  <td>Document remove operations performed</td>
	  <td>operation</td>
	  <td>rate</td>
	</tr>
	<tr>
	  <td>httpapi_num_puts</td>
	  <td>Document put operations performed</td>
	  <td>operation</td>
	  <td>rate</td>
	</tr>
	<tr>
	  <td>httpapi_succeeded</td>
	  <td>Document operations that succeeded</td>
	  <td>operation</td>
	  <td>rate</td>
	</tr>
	<tr>
	  <td>httpapi_failed</td>
	  <td>Document operations that failed</td>
	  <td>operation</td>
	  <td>rate</td>
	</tr>
	<tr>
	  <td>httpapi_parse_error</td>
	  <td>Document operations that failed due to document parse errors</td>
	  <td>operation</td>
	  <td>rate</td>
	</tr>
	<tr>
	  <td>httpapi_condition_not_met</td>
	  <td>Document operations not applied due to condition not met</td>
	  <td>operation</td>
	  <td>rate</td>
	</tr>
	<tr>
	  <td>httpapi_not_found</td>
	  <td>Document operations not applied due to document not found</td>
	  <td>operation</td>
	  <td>rate</td>
	</tr>
	<tr>
	  <td>httpapi_failed_unknown</td>
	  <td>Document operations failed by unknown cause</td>
	  <td>operation</td>
	  <td>rate</td>
	</tr>
	<tr>
	  <td>httpapi_failed_insufficient_storage</td>
	  <td>Document operations failed by insufficient storage</td>
	  <td>operation</td>
	  <td>rate</td>
	</tr>
	<tr>
	  <td>httpapi_failed_timeout</td>
	  <td>Document operations failed by timeout</td>
	  <td>operation</td>
	  <td>rate</td>
	</tr>
	<tr>
	  <td>mem.heap.total</td>
	  <td>Total available heap memory</td>
	  <td>byte</td>
	  <td>average</td>
	</tr>
	<tr>
	  <td>mem.heap.free</td>
	  <td>Free heap memory</td>
	  <td>byte</td>
	  <td>average</td>
	</tr>
	<tr>
	  <td>mem.heap.used</td>
	  <td>Currently used heap memory</td>
	  <td>byte</td>
	  <td>average, max</td>
	</tr>
	<tr>
	  <td>mem.direct.total</td>
	  <td>Total available direct memory</td>
	  <td>byte</td>
	  <td>average</td>
	</tr>
	<tr>
	  <td>mem.direct.free</td>
	  <td>Currently free direct memory</td>
	  <td>byte</td>
	  <td>average</td>
	</tr>
	<tr>
	  <td>mem.direct.used</td>
	  <td>Direct memory currently used</td>
	  <td>byte</td>
	  <td>average, max</td>
	</tr>
	<tr>
	  <td>mem.direct.count</td>
	  <td>Number of direct memory allocations</td>
	  <td>byte</td>
	  <td>max</td>
	</tr>
	<tr>
	  <td>mem.native.total</td>
	  <td>Total available native memory</td>
	  <td>byte</td>
	  <td>average</td>
	</tr>
	<tr>
	  <td>mem.native.free</td>
	  <td>Currently free native memory</td>
	  <td>byte</td>
	  <td>average</td>
	</tr>
	<tr>
	  <td>mem.native.used</td>
	  <td>Native memory currently used</td>
	  <td>byte</td>
	  <td>average</td>
	</tr>
	<tr>
	  <td>jdisc.memory_mappings</td>
	  <td>JDISC Memory mappings</td>
	  <td>operation</td>
	  <td>max</td>
	</tr>
	<tr>
	  <td>jdisc.open_file_descriptors</td>
	  <td>JDISC Open file descriptors</td>
	  <td>item</td>
	  <td>max</td>
	</tr>
	<tr>
	  <td>jdisc.gc.count</td>
	  <td>Number of JVM garbage collections done</td>
	  <td>operation</td>
	  <td>average, max, last</td>
	</tr>
	<tr>
	  <td>jdisc.gc.ms</td>
	  <td>Time spent in JVM garbage collection</td>
	  <td>millisecond</td>
	  <td>average, max, last</td>
	</tr>
	<tr>
	  <td>jdisc.deactivated_containers.total</td>
	  <td>JDISC Deactivated container instances</td>
	  <td>item</td>
	  <td>last</td>
	</tr>
	<tr>
	  <td>jdisc.deactivated_containers.with_retained_refs.last</td>
	  <td>JDISC Deactivated container nodes with retained refs</td>
	  <td>item</td>
	  <td>last</td>
	</tr>
	<tr>
	  <td>jdisc.singleton.is_active</td>
	  <td>JDISC Singleton is active</td>
	  <td>item</td>
	  <td>last</td>
	</tr>
	<tr>
	  <td>jdisc.singleton.activation.count</td>
	  <td>JDISC Singleton activations</td>
	  <td>operation</td>
	  <td>last</td>
	</tr>
	<tr>
	  <td>jdisc.singleton.activation.failure.count</td>
	  <td>JDISC Singleton activation failures</td>
	  <td>operation</td>
	  <td>last</td>
	</tr>
	<tr>
	  <td>jdisc.singleton.activation.millis</td>
	  <td>JDISC Singleton activation time</td>
	  <td>millisecond</td>
	  <td>last</td>
	</tr>
	<tr>
	  <td>jdisc.singleton.deactivation.count</td>
	  <td>JDISC Singleton deactivations</td>
	  <td>operation</td>
	  <td>last</td>
	</tr>
	<tr>
	  <td>jdisc.singleton.deactivation.failure.count</td>
	  <td>JDISC Singleton deactivation failures</td>
	  <td>operation</td>
	  <td>last</td>
	</tr>
	<tr>
	  <td>jdisc.singleton.deactivation.millis</td>
	  <td>JDISC Singleton deactivation time</td>
	  <td>millisecond</td>
	  <td>last</td>
	</tr>
	<tr>
	  <td>athenz-tenant-cert.expiry.seconds</td>
	  <td>Time remaining until Athenz tenant certificate expires</td>
	  <td>second</td>
	  <td>last</td>
	</tr>
	<tr>
	  <td>container-iam-role.expiry.seconds</td>
	  <td>Time remaining until IAM role expires</td>
	  <td>second</td>
	  <td>N/A</td>
	</tr>
	<tr>
	  <td>http.status.1xx</td>
	  <td>Number of responses with a 1xx status</td>
	  <td>response</td>
	  <td>rate</td>
	</tr>
	<tr>
	  <td>http.status.2xx</td>
	  <td>Number of responses with a 2xx status</td>
	  <td>response</td>
	  <td>rate</td>
	</tr>
	<tr>
	  <td>http.status.3xx</td>
	  <td>Number of responses with a 3xx status</td>
	  <td>response</td>
	  <td>rate</td>
	</tr>
	<tr>
	  <td>http.status.4xx</td>
	  <td>Number of responses with a 4xx status</td>
	  <td>response</td>
	  <td>rate</td>
	</tr>
	<tr>
	  <td>http.status.5xx</td>
	  <td>Number of responses with a 5xx status</td>
	  <td>response</td>
	  <td>rate</td>
	</tr>
	<tr>
	  <td>jdisc.http.request.prematurely_closed</td>
	  <td>HTTP requests prematurely closed</td>
	  <td>request</td>
	  <td>rate</td>
	</tr>
	<tr>
	  <td>jdisc.http.request.requests_per_connection</td>
	  <td>HTTP requests per connection</td>
	  <td>request</td>
	  <td>sum, count, min, max, average</td>
	</tr>
	<tr>
	  <td>jdisc.http.request.uri_length</td>
	  <td>HTTP URI length</td>
	  <td>byte</td>
	  <td>sum, count, max</td>
	</tr>
	<tr>
	  <td>jdisc.http.request.content_size</td>
	  <td>HTTP request content size</td>
	  <td>byte</td>
	  <td>sum, count, max</td>
	</tr>
	<tr>
	  <td>jdisc.http.requests</td>
	  <td>HTTP requests</td>
	  <td>request</td>
	  <td>rate, count</td>
	</tr>
	<tr>
	  <td>jdisc.http.ssl.handshake.failure.missing_client_cert</td>
	  <td>JDISC HTTP SSL Handshake failures due to missing client certificate</td>
	  <td>operation</td>
	  <td>rate</td>
	</tr>
	<tr>
	  <td>jdisc.http.ssl.handshake.failure.expired_client_cert</td>
	  <td>JDISC HTTP SSL Handshake failures due to expired client certificate</td>
	  <td>operation</td>
	  <td>rate</td>
	</tr>
	<tr>
	  <td>jdisc.http.ssl.handshake.failure.invalid_client_cert</td>
	  <td>JDISC HTTP SSL Handshake failures due to invalid client certificate</td>
	  <td>operation</td>
	  <td>rate</td>
	</tr>
	<tr>
	  <td>jdisc.http.ssl.handshake.failure.incompatible_protocols</td>
	  <td>JDISC HTTP SSL Handshake failures due to inincompatible protocols</td>
	  <td>operation</td>
	  <td>rate</td>
	</tr>
	<tr>
	  <td>jdisc.http.ssl.handshake.failure.incompatible_chifers</td>
	  <td>JDISC HTTP SSL Handshake failures due to incompatible chifers</td>
	  <td>operation</td>
	  <td>rate</td>
	</tr>
	<tr>
	  <td>jdisc.http.ssl.handshake.failure.connection_closed</td>
	  <td>JDISC HTTP SSL Handshake failures due to connection closed</td>
	  <td>operation</td>
	  <td>rate</td>
	</tr>
	<tr>
	  <td>jdisc.http.ssl.handshake.failure.unknown</td>
	  <td>JDISC HTTP SSL Handshake failures for unknown reason</td>
	  <td>operation</td>
	  <td>rate</td>
	</tr>
	<tr>
	  <td>jdisc.http.filter.rule.blocked_requests</td>
	  <td>Number of requests blocked by filter</td>
	  <td>request</td>
	  <td>rate</td>
	</tr>
	<tr>
	  <td>jdisc.http.filter.rule.allowed_requests</td>
	  <td>Number of requests allowed by filter</td>
	  <td>request</td>
	  <td>rate</td>
	</tr>
	<tr>
	  <td>jdisc.http.filtering.request.handled</td>
	  <td>Number of filtering requests handled</td>
	  <td>request</td>
	  <td>rate</td>
	</tr>
	<tr>
	  <td>jdisc.http.filtering.request.unhandled</td>
	  <td>Number of filtering requests unhandled</td>
	  <td>request</td>
	  <td>rate</td>
	</tr>
	<tr>
	  <td>jdisc.http.filtering.response.handled</td>
	  <td>Number of filtering responses handled</td>
	  <td>request</td>
	  <td>rate</td>
	</tr>
	<tr>
	  <td>jdisc.http.filtering.response.unhandled</td>
	  <td>Number of filtering responses unhandled</td>
	  <td>request</td>
	  <td>rate</td>
	</tr>
	<tr>
	  <td>jdisc.http.handler.unhandled_exceptions</td>
	  <td>Number of unhandled exceptions in handler</td>
	  <td>request</td>
	  <td>rate</td>
	</tr>
	<tr>
	  <td>jdisc.application.failed_component_graphs</td>
	  <td>JDISC Application failed component graphs</td>
	  <td>item</td>
	  <td>rate</td>
	</tr>
	<tr>
	  <td>jdisc.jvm</td>
	  <td>JVM runtime version</td>
	  <td>version</td>
	  <td>last</td>
	</tr>
	<tr>
	  <td>serverRejectedRequests</td>
	  <td>Deprecated. Use jdisc.thread_pool.rejected_tasks instead.</td>
	  <td>operation</td>
	  <td>rate, count</td>
	</tr>
	<tr>
	  <td>serverThreadPoolSize</td>
	  <td>Deprecated. Use jdisc.thread_pool.size instead.</td>
	  <td>thread</td>
	  <td>max, last</td>
	</tr>
	<tr>
	  <td>serverActiveThreads</td>
	  <td>Deprecated. Use jdisc.thread_pool.active_threads instead.</td>
	  <td>thread</td>
	  <td>min, max, sum, count, last</td>
	</tr>
	<tr>
	  <td>jdisc.tls.capability_checks.succeeded</td>
	  <td>Number of TLS capability checks succeeded</td>
	  <td>operation</td>
	  <td>rate</td>
	</tr>
	<tr>
	  <td>jdisc.tls.capability_checks.failed</td>
	  <td>Number of TLS capability checks failed</td>
	  <td>operation</td>
	  <td>rate</td>
	</tr>
	<tr>
	  <td>peak_qps</td>
	  <td>The highest number of qps for a second for this metrics shapshot</td>
	  <td>query/second</td>
	  <td>max</td>
	</tr>
	<tr>
	  <td>search_connections</td>
	  <td>Number of search connections</td>
	  <td>connection</td>
	  <td>sum, count, max</td>
	</tr>
	<tr>
	  <td>feed.latency</td>
	  <td>Feed latency</td>
	  <td>millisecond</td>
	  <td>sum, count, max</td>
	</tr>
	<tr>
	  <td>feed.http-requests</td>
	  <td>Feed HTTP requests</td>
	  <td>operation</td>
	  <td>count, rate</td>
	</tr>
	<tr>
	  <td>queries</td>
	  <td>Query volume</td>
	  <td>operation</td>
	  <td>rate</td>
	</tr>
	<tr>
	  <td>query_container_latency</td>
	  <td>The query execution time consumed in the container</td>
	  <td>millisecond</td>
	  <td>sum, count, max</td>
	</tr>
	<tr>
	  <td>query_latency</td>
	  <td>The overall query latency as seen by the container</td>
	  <td>millisecond</td>
	  <td>sum, count, max, 95percentile, 99percentile</td>
	</tr>
	<tr>
	  <td>query_timeout</td>
	  <td>The amount of time allowed for query execytion, from the client</td>
	  <td>millisecond</td>
	  <td>sum, count, max, min, 95percentile, 99percentile</td>
	</tr>
	<tr>
	  <td>failed_queries</td>
	  <td>The number of failed queries</td>
	  <td>operation</td>
	  <td>rate</td>
	</tr>
	<tr>
	  <td>degraded_queries</td>
	  <td>The number of degraded queries, e.g. due to some conent nodes not responding in time</td>
	  <td>operation</td>
	  <td>rate</td>
	</tr>
	<tr>
	  <td>hits_per_query</td>
	  <td>The number of hits returned</td>
	  <td>hit/query</td>
	  <td>sum, count, max, 95percentile, 99percentile</td>
	</tr>
	<tr>
	  <td>search_connections</td>
	  <td>Number of search connections</td>
	  <td>connection</td>
	  <td>sum, count, max</td>
	</tr>
	<tr>
	  <td>query_hit_offset</td>
	  <td>The offset for hits returned</td>
	  <td>hit</td>
	  <td>sum, count, max</td>
	</tr>
	<tr>
	  <td>documents_covered</td>
	  <td>The combined number of documents considered during query evaluation</td>
	  <td>document</td>
	  <td>count</td>
	</tr>
	<tr>
	  <td>documents_total</td>
	  <td>The number of documents to be evaluated if all requests had been fully executed</td>
	  <td>document</td>
	  <td>count</td>
	</tr>
	<tr>
	  <td>documents_target_total</td>
	  <td>The target number of total documents to be evaluated when when all data is in sync</td>
	  <td>document</td>
	  <td>count</td>
	</tr>
	<tr>
	  <td>jdisc.render.latency</td>
	  <td>The time used by the container to render responses</td>
	  <td>nanosecond</td>
	  <td>min, max, count, sum, last, average</td>
	</tr>
	<tr>
	  <td>query_item_count</td>
	  <td>The number of query items (terms, phrases, etc)</td>
	  <td>item</td>
	  <td>max, sum, count</td>
	</tr>
	<tr>
	  <td>totalhits_per_query</td>
	  <td>The total number of documents found to match queries</td>
	  <td>hit/query</td>
	  <td>sum, count, max, 95percentile, 99percentile</td>
	</tr>
	<tr>
	  <td>empty_results</td>
	  <td>Number of queries matching no documents</td>
	  <td>operation</td>
	  <td>rate</td>
	</tr>
	<tr>
	  <td>requestsOverQuota</td>
	  <td>The number of requests rejected due to exceeding quota</td>
	  <td>operation</td>
	  <td>rate, count</td>
	</tr>
	<tr>
	  <td>docproc.proctime</td>
	  <td>Time spent processing document</td>
	  <td>millisecond</td>
	  <td>sum, count, max</td>
	</tr>
	<tr>
	  <td>docproc.documents</td>
	  <td>Number of processed documents</td>
	  <td>document</td>
	  <td>sum, count, max, min</td>
	</tr>
	<tr>
	  <td>relevance.at_1</td>
	  <td>The relevance of hit number 1</td>
	  <td>score</td>
	  <td>sum, count</td>
	</tr>
	<tr>
	  <td>relevance.at_3</td>
	  <td>The relevance of hit number 3</td>
	  <td>score</td>
	  <td>sum, count</td>
	</tr>
	<tr>
	  <td>relevance.at_10</td>
	  <td>The relevance of hit number 10</td>
	  <td>score</td>
	  <td>sum, count</td>
	</tr>
	<tr>
	  <td>error.timeout</td>
	  <td>Requests that timed out</td>
	  <td>operation</td>
	  <td>rate</td>
	</tr>
	<tr>
	  <td>error.backends_oos</td>
	  <td>Requests that failed due to no available backends nodes</td>
	  <td>operation</td>
	  <td>rate</td>
	</tr>
	<tr>
	  <td>error.plugin_failure</td>
	  <td>Requests that failed due to plugin failure</td>
	  <td>operation</td>
	  <td>rate</td>
	</tr>
	<tr>
	  <td>error.backend_communication_error</td>
	  <td>Requests that failed due to backend communication error</td>
	  <td>operation</td>
	  <td>rate</td>
	</tr>
	<tr>
	  <td>error.empty_document_summaries</td>
	  <td>Requests that failed due to missing document summaries</td>
	  <td>operation</td>
	  <td>rate</td>
	</tr>
	<tr>
	  <td>error.invalid_query_parameter</td>
	  <td>Requests that failed due to invalid query parameters</td>
	  <td>operation</td>
	  <td>rate</td>
	</tr>
	<tr>
	  <td>error.internal_server_error</td>
	  <td>Requests that failed due to internal server error</td>
	  <td>operation</td>
	  <td>rate</td>
	</tr>
	<tr>
	  <td>error.misconfigured_server</td>
	  <td>Requests that failed due to misconfigured server</td>
	  <td>operation</td>
	  <td>rate</td>
	</tr>
	<tr>
	  <td>error.invalid_query_transformation</td>
	  <td>Requests that failed due to invalid query transformation</td>
	  <td>operation</td>
	  <td>rate</td>
	</tr>
	<tr>
	  <td>error.results_with_errors</td>
	  <td>The number of queries with error payload</td>
	  <td>operation</td>
	  <td>rate</td>
	</tr>
	<tr>
	  <td>error.unspecified</td>
	  <td>Requests that failed for an unspecified reason</td>
	  <td>operation</td>
	  <td>rate</td>
	</tr>
	<tr>
	  <td>error.unhandled_exception</td>
	  <td>Requests that failed due to an unhandled exception</td>
	  <td>operation</td>
	  <td>rate</td>
	</tr>
    </tbody>
</table>

<h2 id=distributor-metrics>Distributor Metrics</h2>
<table class="table">
    <thead>
        <tr><th>Name</th><th>Description</th><th>Unit</th><th>Suffixes</th></tr>
    </thead>
    <tbody>
	<tr>
	  <td>vds.idealstate.buckets_rechecking</td>
	  <td>The number of buckets that we are rechecking for ideal state operations</td>
	  <td>bucket</td>
	  <td>average</td>
	</tr>
	<tr>
	  <td>vds.idealstate.idealstate_diff</td>
	  <td>A number representing the current difference from the ideal state. This is a number that decreases steadily as the system is getting closer to the ideal state</td>
	  <td>bucket</td>
	  <td>average</td>
	</tr>
	<tr>
	  <td>vds.idealstate.buckets_toofewcopies</td>
	  <td>The number of buckets the distributor controls that have less than the desired redundancy</td>
	  <td>bucket</td>
	  <td>average</td>
	</tr>
	<tr>
	  <td>vds.idealstate.buckets_toomanycopies</td>
	  <td>The number of buckets the distributor controls that have more than the desired redundancy</td>
	  <td>bucket</td>
	  <td>average</td>
	</tr>
	<tr>
	  <td>vds.idealstate.buckets</td>
	  <td>The number of buckets the distributor controls</td>
	  <td>bucket</td>
	  <td>average</td>
	</tr>
	<tr>
	  <td>vds.idealstate.buckets_notrusted</td>
	  <td>The number of buckets that have no trusted copies.</td>
	  <td>bucket</td>
	  <td>average</td>
	</tr>
	<tr>
	  <td>vds.idealstate.bucket_replicas_moving_out</td>
	  <td>Bucket replicas that should be moved out, e.g. retirement case or node added to cluster that has higher ideal state priority.</td>
	  <td>bucket</td>
	  <td>average</td>
	</tr>
	<tr>
	  <td>vds.idealstate.bucket_replicas_copying_out</td>
	  <td>Bucket replicas that should be copied out, e.g. node is in ideal state but might have to provide data other nodes in a merge</td>
	  <td>bucket</td>
	  <td>average</td>
	</tr>
	<tr>
	  <td>vds.idealstate.bucket_replicas_copying_in</td>
	  <td>Bucket replicas that should be copied in, e.g. node does not have a replica for a bucket that it is in ideal state for</td>
	  <td>bucket</td>
	  <td>average</td>
	</tr>
	<tr>
	  <td>vds.idealstate.bucket_replicas_syncing</td>
	  <td>Bucket replicas that need syncing due to mismatching metadata</td>
	  <td>bucket</td>
	  <td>average</td>
	</tr>
	<tr>
	  <td>vds.idealstate.max_observed_time_since_last_gc_sec</td>
	  <td>Maximum time (in seconds) since GC was last successfully run for a bucket. Aggregated max value across all buckets on the distributor.</td>
	  <td>second</td>
	  <td>average</td>
	</tr>
	<tr>
	  <td>vds.idealstate.delete_bucket.done_ok</td>
	  <td>The number of operations successfully performed</td>
	  <td>operation</td>
	  <td>rate</td>
	</tr>
	<tr>
	  <td>vds.idealstate.delete_bucket.done_failed</td>
	  <td>The number of operations that failed</td>
	  <td>operation</td>
	  <td>rate</td>
	</tr>
	<tr>
	  <td>vds.idealstate.delete_bucket.pending</td>
	  <td>The number of operations pending</td>
	  <td>operation</td>
	  <td>average</td>
	</tr>
	<tr>
	  <td>vds.idealstate.merge_bucket.done_ok</td>
	  <td>The number of operations successfully performed</td>
	  <td>operation</td>
	  <td>rate</td>
	</tr>
	<tr>
	  <td>vds.idealstate.merge_bucket.done_failed</td>
	  <td>The number of operations that failed</td>
	  <td>operation</td>
	  <td>rate</td>
	</tr>
	<tr>
	  <td>vds.idealstate.merge_bucket.pending</td>
	  <td>The number of operations pending</td>
	  <td>operation</td>
	  <td>average</td>
	</tr>
	<tr>
	  <td>vds.idealstate.merge_bucket.blocked</td>
	  <td>The number of operations blocked by blocking operation starter</td>
	  <td>operation</td>
	  <td>rate</td>
	</tr>
	<tr>
	  <td>vds.idealstate.merge_bucket.throttled</td>
	  <td>The number of operations throttled by throttling operation starter</td>
	  <td>operation</td>
	  <td>rate</td>
	</tr>
	<tr>
	  <td>vds.idealstate.merge_bucket.source_only_copy_changed</td>
	  <td>The number of merge operations where source-only copy changed</td>
	  <td>operation</td>
	  <td>rate</td>
	</tr>
	<tr>
	  <td>vds.idealstate.merge_bucket.source_only_copy_delete_blocked</td>
	  <td>The number of merge operations where delete of unchanged source-only copies was blocked</td>
	  <td>operation</td>
	  <td>rate</td>
	</tr>
	<tr>
	  <td>vds.idealstate.merge_bucket.source_only_copy_delete_failed</td>
	  <td>The number of merge operations where delete of unchanged source-only copies failed</td>
	  <td>operation</td>
	  <td>rate</td>
	</tr>
	<tr>
	  <td>vds.idealstate.split_bucket.done_ok</td>
	  <td>The number of operations successfully performed</td>
	  <td>operation</td>
	  <td>rate</td>
	</tr>
	<tr>
	  <td>vds.idealstate.split_bucket.done_failed</td>
	  <td>The number of operations that failed</td>
	  <td>operation</td>
	  <td>rate</td>
	</tr>
	<tr>
	  <td>vds.idealstate.split_bucket.pending</td>
	  <td>The number of operations pending</td>
	  <td>operation</td>
	  <td>average</td>
	</tr>
	<tr>
	  <td>vds.idealstate.join_bucket.done_ok</td>
	  <td>The number of operations successfully performed</td>
	  <td>operation</td>
	  <td>rate</td>
	</tr>
	<tr>
	  <td>vds.idealstate.join_bucket.done_failed</td>
	  <td>The number of operations that failed</td>
	  <td>operation</td>
	  <td>rate</td>
	</tr>
	<tr>
	  <td>vds.idealstate.join_bucket.pending</td>
	  <td>The number of operations pending</td>
	  <td>operation</td>
	  <td>average</td>
	</tr>
	<tr>
	  <td>vds.idealstate.garbage_collection.done_ok</td>
	  <td>The number of operations successfully performed</td>
	  <td>operation</td>
	  <td>rate</td>
	</tr>
	<tr>
	  <td>vds.idealstate.garbage_collection.done_failed</td>
	  <td>The number of operations that failed</td>
	  <td>operation</td>
	  <td>rate</td>
	</tr>
	<tr>
	  <td>vds.idealstate.garbage_collection.pending</td>
	  <td>The number of operations pending</td>
	  <td>operation</td>
	  <td>average</td>
	</tr>
	<tr>
	  <td>vds.idealstate.garbage_collection.documents_removed</td>
	  <td>Number of documents removed by GC operations</td>
	  <td>document</td>
	  <td>count, rate</td>
	</tr>
	<tr>
	  <td>vds.distributor.puts.latency</td>
	  <td>The latency of put operations</td>
	  <td>millisecond</td>
	  <td>max, sum, count</td>
	</tr>
	<tr>
	  <td>vds.distributor.puts.ok</td>
	  <td>The number of successful put operations performed</td>
	  <td>operation</td>
	  <td>rate</td>
	</tr>
	<tr>
	  <td>vds.distributor.puts.failures.total</td>
	  <td>Sum of all failures</td>
	  <td>operation</td>
	  <td>rate</td>
	</tr>
	<tr>
	  <td>vds.distributor.puts.failures.notfound</td>
	  <td>The number of operations that failed because the document did not exist</td>
	  <td>operation</td>
	  <td>rate</td>
	</tr>
	<tr>
	  <td>vds.distributor.puts.failures.test_and_set_failed</td>
	  <td>The number of mutating operations that failed because they specified a test-and-set condition that did not match the existing document</td>
	  <td>operation</td>
	  <td>rate</td>
	</tr>
	<tr>
	  <td>vds.distributor.puts.failures.concurrent_mutations</td>
	  <td>The number of operations that were transiently failed due to a mutating operation already being in progress for its document ID</td>
	  <td>operation</td>
	  <td>rate</td>
	</tr>
	<tr>
	  <td>vds.distributor.puts.failures.notconnected</td>
	  <td>The number of operations discarded because there were no available storage nodes to send to</td>
	  <td>operation</td>
	  <td>rate</td>
	</tr>
	<tr>
	  <td>vds.distributor.puts.failures.notready</td>
	  <td>The number of operations discarded because distributor was not ready</td>
	  <td>operation</td>
	  <td>rate</td>
	</tr>
	<tr>
	  <td>vds.distributor.puts.failures.wrongdistributor</td>
	  <td>The number of operations discarded because they were sent to the wrong distributor</td>
	  <td>operation</td>
	  <td>rate</td>
	</tr>
	<tr>
	  <td>vds.distributor.puts.failures.safe_time_not_reached</td>
	  <td>The number of operations that were transiently failed due to them arriving before the safe time point for bucket ownership handovers has passed</td>
	  <td>operation</td>
	  <td>rate</td>
	</tr>
	<tr>
	  <td>vds.distributor.puts.failures.storagefailure</td>
	  <td>The number of operations that failed in storage</td>
	  <td>operation</td>
	  <td>rate</td>
	</tr>
	<tr>
	  <td>vds.distributor.puts.failures.timeout</td>
	  <td>The number of operations that failed because the operation timed out towards storage</td>
	  <td>operation</td>
	  <td>rate</td>
	</tr>
	<tr>
	  <td>vds.distributor.puts.failures.busy</td>
	  <td>The number of messages from storage that failed because the storage node was busy</td>
	  <td>operation</td>
	  <td>rate</td>
	</tr>
	<tr>
	  <td>vds.distributor.puts.failures.inconsistent_bucket</td>
	  <td>The number of operations failed due to buckets being in an inconsistent state or not found</td>
	  <td>operation</td>
	  <td>rate</td>
	</tr>
	<tr>
	  <td>vds.distributor.removes.latency</td>
	  <td>The latency of remove operations</td>
	  <td>millisecond</td>
	  <td>max, sum, count</td>
	</tr>
	<tr>
	  <td>vds.distributor.removes.ok</td>
	  <td>The number of successful removes operations performed</td>
	  <td>operation</td>
	  <td>rate</td>
	</tr>
	<tr>
	  <td>vds.distributor.removes.failures.total</td>
	  <td>Sum of all failures</td>
	  <td>operation</td>
	  <td>rate</td>
	</tr>
	<tr>
	  <td>vds.distributor.removes.failures.notfound</td>
	  <td>The number of operations that failed because the document did not exist</td>
	  <td>operation</td>
	  <td>rate</td>
	</tr>
	<tr>
	  <td>vds.distributor.removes.failures.test_and_set_failed</td>
	  <td>The number of mutating operations that failed because they specified a test-and-set condition that did not match the existing document</td>
	  <td>operation</td>
	  <td>rate</td>
	</tr>
	<tr>
	  <td>vds.distributor.removes.failures.concurrent_mutations</td>
	  <td>The number of operations that were transiently failed due to a mutating operation already being in progress for its document ID</td>
	  <td>operation</td>
	  <td>rate</td>
	</tr>
	<tr>
	  <td>vds.distributor.updates.latency</td>
	  <td>The latency of update operations</td>
	  <td>millisecond</td>
	  <td>max, sum, count</td>
	</tr>
	<tr>
	  <td>vds.distributor.updates.ok</td>
	  <td>The number of successful updates operations performed</td>
	  <td>operation</td>
	  <td>rate</td>
	</tr>
	<tr>
	  <td>vds.distributor.updates.failures.total</td>
	  <td>Sum of all failures</td>
	  <td>operation</td>
	  <td>rate</td>
	</tr>
	<tr>
	  <td>vds.distributor.updates.failures.notfound</td>
	  <td>The number of operations that failed because the document did not exist</td>
	  <td>operation</td>
	  <td>rate</td>
	</tr>
	<tr>
	  <td>vds.distributor.updates.failures.test_and_set_failed</td>
	  <td>The number of mutating operations that failed because they specified a test-and-set condition that did not match the existing document</td>
	  <td>operation</td>
	  <td>rate</td>
	</tr>
	<tr>
	  <td>vds.distributor.updates.failures.concurrent_mutations</td>
	  <td>The number of operations that were transiently failed due to a mutating operation already being in progress for its document ID</td>
	  <td>operation</td>
	  <td>rate</td>
	</tr>
	<tr>
	  <td>vds.distributor.updates.diverging_timestamp_updates</td>
	  <td>Number of updates that report they were performed against divergent version timestamps on different replicas</td>
	  <td>operation</td>
	  <td>rate</td>
	</tr>
	<tr>
	  <td>vds.distributor.removelocations.ok</td>
	  <td>The number of successful removelocations operations performed</td>
	  <td>operation</td>
	  <td>rate</td>
	</tr>
	<tr>
	  <td>vds.distributor.removelocations.failures.total</td>
	  <td>Sum of all failures</td>
	  <td>operation</td>
	  <td>rate</td>
	</tr>
	<tr>
	  <td>vds.distributor.gets.latency</td>
	  <td>The average latency of gets operations</td>
	  <td>millisecond</td>
	  <td>max, sum, count</td>
	</tr>
	<tr>
	  <td>vds.distributor.gets.ok</td>
	  <td>The number of successful gets operations performed</td>
	  <td>operation</td>
	  <td>rate</td>
	</tr>
	<tr>
	  <td>vds.distributor.gets.failures.total</td>
	  <td>Sum of all failures</td>
	  <td>operation</td>
	  <td>rate</td>
	</tr>
	<tr>
	  <td>vds.distributor.gets.failures.notfound</td>
	  <td>The number of operations that failed because the document did not exist</td>
	  <td>operation</td>
	  <td>rate</td>
	</tr>
	<tr>
	  <td>vds.distributor.visitor.latency</td>
	  <td>The average latency of visitor operations</td>
	  <td>millisecond</td>
	  <td>max, sum, count</td>
	</tr>
	<tr>
	  <td>vds.distributor.visitor.ok</td>
	  <td>The number of successful visitor operations performed</td>
	  <td>operation</td>
	  <td>rate</td>
	</tr>
	<tr>
	  <td>vds.distributor.visitor.failures.total</td>
	  <td>Sum of all failures</td>
	  <td>operation</td>
	  <td>rate</td>
	</tr>
	<tr>
	  <td>vds.distributor.visitor.failures.notready</td>
	  <td>The number of operations discarded because distributor was not ready</td>
	  <td>operation</td>
	  <td>rate</td>
	</tr>
	<tr>
	  <td>vds.distributor.visitor.failures.notconnected</td>
	  <td>The number of operations discarded because there were no available storage nodes to send to</td>
	  <td>operation</td>
	  <td>rate</td>
	</tr>
	<tr>
	  <td>vds.distributor.visitor.failures.wrongdistributor</td>
	  <td>The number of operations discarded because they were sent to the wrong distributor</td>
	  <td>operation</td>
	  <td>rate</td>
	</tr>
	<tr>
	  <td>vds.distributor.visitor.failures.safe_time_not_reached</td>
	  <td>The number of operations that were transiently failed due to them arriving before the safe time point for bucket ownership handovers has passed</td>
	  <td>operation</td>
	  <td>rate</td>
	</tr>
	<tr>
	  <td>vds.distributor.visitor.failures.storagefailure</td>
	  <td>The number of operations that failed in storage</td>
	  <td>operation</td>
	  <td>rate</td>
	</tr>
	<tr>
	  <td>vds.distributor.visitor.failures.timeout</td>
	  <td>The number of operations that failed because the operation timed out towards storage</td>
	  <td>operation</td>
	  <td>rate</td>
	</tr>
	<tr>
	  <td>vds.distributor.visitor.failures.busy</td>
	  <td>The number of messages from storage that failed because the storage node was busy</td>
	  <td>operation</td>
	  <td>rate</td>
	</tr>
	<tr>
	  <td>vds.distributor.visitor.failures.inconsistent_bucket</td>
	  <td>The number of operations failed due to buckets being in an inconsistent state or not found</td>
	  <td>operation</td>
	  <td>rate</td>
	</tr>
	<tr>
	  <td>vds.distributor.visitor.failures.notfound</td>
	  <td>The number of operations that failed because the document did not exist</td>
	  <td>operation</td>
	  <td>rate</td>
	</tr>
	<tr>
	  <td>vds.distributor.docsstored</td>
	  <td>Number of documents stored in all buckets controlled by this distributor</td>
	  <td>document</td>
	  <td>average</td>
	</tr>
	<tr>
	  <td>vds.distributor.bytesstored</td>
	  <td>Number of bytes stored in all buckets controlled by this distributor</td>
	  <td>byte</td>
	  <td>average</td>
	</tr>
	<tr>
	  <td>vds.bouncer.clock_skew_aborts</td>
	  <td>Number of client operations that were aborted due to clock skew between sender and receiver exceeding acceptable range</td>
	  <td>operation</td>
	  <td>count</td>
	</tr>
    </tbody>
</table>

<h2 id=logd-metrics>Logd Metrics</h2>
<table class="table">
    <thead>
        <tr><th>Name</th><th>Description</th><th>Unit</th><th>Suffixes</th></tr>
    </thead>
    <tbody>
	<tr>
	  <td>logd.processed.lines</td>
	  <td>Number of log lines processed</td>
	  <td>item</td>
	  <td>count</td>
	</tr>
    </tbody>
</table>

<h2 id=nodeadmin-metrics>Nodeadmin Metrics</h2>
<table class="table">
    <thead>
        <tr><th>Name</th><th>Description</th><th>Unit</th><th>Suffixes</th></tr>
    </thead>
    <tbody>
	<tr>
	  <td>endpoint.certificate.expiry.seconds</td>
	  <td>Time until node endpoint certificate expires</td>
	  <td>second</td>
	  <td>N/A</td>
	</tr>
	<tr>
	  <td>node-certificate.expiry.seconds</td>
	  <td>Time until node certificate expires</td>
	  <td>second</td>
	  <td>N/A</td>
	</tr>
    </tbody>
</table>

<h2 id=searchnode-metrics>Searchnode Metrics</h2>
<table class="table">
    <thead>
        <tr><th>Name</th><th>Description</th><th>Unit</th><th>Suffixes</th></tr>
    </thead>
    <tbody>
	<tr>
	  <td>content.proton.config.generation</td>
	  <td>The oldest config generation used by this search node</td>
	  <td>version</td>
	  <td>last</td>
	</tr>
	<tr>
	  <td>content.proton.documentdb.documents.total</td>
	  <td>The total number of documents in this documents db (ready + not-ready)</td>
	  <td>document</td>
	  <td>last</td>
	</tr>
	<tr>
	  <td>content.proton.documentdb.documents.ready</td>
	  <td>The number of ready documents in this document db</td>
	  <td>document</td>
	  <td>last</td>
	</tr>
	<tr>
	  <td>content.proton.documentdb.documents.active</td>
	  <td>The number of active / searchable documents in this document db</td>
	  <td>document</td>
	  <td>last</td>
	</tr>
	<tr>
	  <td>content.proton.documentdb.documents.removed</td>
	  <td>The number of removed documents in this document db</td>
	  <td>document</td>
	  <td>last</td>
	</tr>
	<tr>
	  <td>content.proton.documentdb.index.docs_in_memory</td>
	  <td>Number of documents in memory index</td>
	  <td>document</td>
	  <td>last</td>
	</tr>
	<tr>
	  <td>content.proton.documentdb.disk_usage</td>
	  <td>The total disk usage (in bytes) for this document db</td>
	  <td>byte</td>
	  <td>last</td>
	</tr>
	<tr>
	  <td>content.proton.documentdb.memory_usage.allocated_bytes</td>
	  <td>The number of allocated bytes</td>
	  <td>byte</td>
	  <td>max</td>
	</tr>
	<tr>
	  <td>content.proton.documentdb.heart_beat_age</td>
	  <td>How long ago (in seconds) heart beat maintenace job was run</td>
	  <td>second</td>
	  <td>last</td>
	</tr>
	<tr>
	  <td>content.proton.docsum.docs</td>
	  <td>Total docsums returned</td>
	  <td>document</td>
	  <td>rate</td>
	</tr>
	<tr>
	  <td>content.proton.docsum.latency</td>
	  <td>Docsum request latency</td>
	  <td>millisecond</td>
	  <td>max, sum, count</td>
	</tr>
	<tr>
	  <td>content.proton.search_protocol.query.latency</td>
	  <td>Query request latency (seconds)</td>
	  <td>second</td>
	  <td>max, sum, count</td>
	</tr>
	<tr>
	  <td>content.proton.search_protocol.query.request_size</td>
	  <td>Query request size (network bytes)</td>
	  <td>byte</td>
	  <td>max, sum, count</td>
	</tr>
	<tr>
	  <td>content.proton.search_protocol.query.reply_size</td>
	  <td>Query reply size (network bytes)</td>
	  <td>byte</td>
	  <td>max, sum, count</td>
	</tr>
	<tr>
	  <td>content.proton.search_protocol.docsum.latency</td>
	  <td>Docsum request latency (seconds)</td>
	  <td>second</td>
	  <td>max, sum, average</td>
	</tr>
	<tr>
	  <td>content.proton.search_protocol.docsum.request_size</td>
	  <td>Docsum request size (network bytes)</td>
	  <td>byte</td>
	  <td>max, sum, count</td>
	</tr>
	<tr>
	  <td>content.proton.search_protocol.docsum.reply_size</td>
	  <td>Docsum reply size (network bytes)</td>
	  <td>byte</td>
	  <td>max, sum, count</td>
	</tr>
	<tr>
	  <td>content.proton.search_protocol.docsum.requested_documents</td>
	  <td>Total requested document summaries</td>
	  <td>document</td>
	  <td>count</td>
	</tr>
	<tr>
	  <td>content.proton.executor.proton.queuesize</td>
	  <td>Size of executor proton task queue</td>
	  <td>task</td>
	  <td>max, sum, count</td>
	</tr>
	<tr>
	  <td>content.proton.executor.proton.accepted</td>
	  <td>Number of executor proton accepted tasks</td>
	  <td>task</td>
	  <td>rate</td>
	</tr>
	<tr>
	  <td>content.proton.executor.proton.wakeups</td>
	  <td>Number of times a executor proton worker thread has been woken up</td>
	  <td>wakeup</td>
	  <td>rate</td>
	</tr>
	<tr>
	  <td>content.proton.executor.proton.utilization</td>
	  <td>Ratio of time the executor proton worker threads has been active</td>
	  <td>fraction</td>
	  <td>max, sum, count</td>
	</tr>
	<tr>
	  <td>content.proton.executor.flush.queuesize</td>
	  <td>Size of executor flush task queue</td>
	  <td>task</td>
	  <td>max, sum, count</td>
	</tr>
	<tr>
	  <td>content.proton.executor.flush.accepted</td>
	  <td>Number of accepted executor flush tasks</td>
	  <td>task</td>
	  <td>rate</td>
	</tr>
	<tr>
	  <td>content.proton.executor.flush.wakeups</td>
	  <td>Number of times a executor flush worker thread has been woken up</td>
	  <td>wakeup</td>
	  <td>rate</td>
	</tr>
	<tr>
	  <td>content.proton.executor.flush.utilization</td>
	  <td>Ratio of time the executor flush worker threads has been active</td>
	  <td>fraction</td>
	  <td>max, sum, count</td>
	</tr>
	<tr>
	  <td>content.proton.executor.match.queuesize</td>
	  <td>Size of executor match task queue</td>
	  <td>task</td>
	  <td>max, sum, count</td>
	</tr>
	<tr>
	  <td>content.proton.executor.match.accepted</td>
	  <td>Number of accepted executor match tasks</td>
	  <td>task</td>
	  <td>rate</td>
	</tr>
	<tr>
	  <td>content.proton.executor.match.wakeups</td>
	  <td>Number of times a executor match worker thread has been woken up</td>
	  <td>wakeup</td>
	  <td>rate</td>
	</tr>
	<tr>
	  <td>content.proton.executor.match.utilization</td>
	  <td>Ratio of time the executor match worker threads has been active</td>
	  <td>fraction</td>
	  <td>max, sum, count</td>
	</tr>
	<tr>
	  <td>content.proton.executor.docsum.queuesize</td>
	  <td>Size of executor docsum task queue</td>
	  <td>task</td>
	  <td>max, sum, count</td>
	</tr>
	<tr>
	  <td>content.proton.executor.docsum.accepted</td>
	  <td>Number of executor accepted docsum tasks</td>
	  <td>task</td>
	  <td>rate</td>
	</tr>
	<tr>
	  <td>content.proton.executor.docsum.wakeups</td>
	  <td>Number of times a executor docsum worker thread has been woken up</td>
	  <td>wakeup</td>
	  <td>rate</td>
	</tr>
	<tr>
	  <td>content.proton.executor.docsum.utilization</td>
	  <td>Ratio of time the executor docsum worker threads has been active</td>
	  <td>fraction</td>
	  <td>max, sum, count</td>
	</tr>
	<tr>
	  <td>content.proton.executor.shared.queuesize</td>
	  <td>Size of executor shared task queue</td>
	  <td>task</td>
	  <td>max, sum, count</td>
	</tr>
	<tr>
	  <td>content.proton.executor.shared.accepted</td>
	  <td>Number of executor shared accepted tasks</td>
	  <td>task</td>
	  <td>rate</td>
	</tr>
	<tr>
	  <td>content.proton.executor.shared.wakeups</td>
	  <td>Number of times a executor shared worker thread has been woken up</td>
	  <td>wakeup</td>
	  <td>rate</td>
	</tr>
	<tr>
	  <td>content.proton.executor.shared.utilization</td>
	  <td>Ratio of time the executor shared worker threads has been active</td>
	  <td>fraction</td>
	  <td>max, sum, count</td>
	</tr>
	<tr>
	  <td>content.proton.executor.warmup.queuesize</td>
	  <td>Size of executor warmup task queue</td>
	  <td>task</td>
	  <td>max, sum, count</td>
	</tr>
	<tr>
	  <td>content.proton.executor.warmup.accepted</td>
	  <td>Number of accepted executor warmup tasks</td>
	  <td>task</td>
	  <td>rate</td>
	</tr>
	<tr>
	  <td>content.proton.executor.warmup.wakeups</td>
	  <td>Number of times a warmup executor worker thread has been woken up</td>
	  <td>wakeup</td>
	  <td>rate</td>
	</tr>
	<tr>
	  <td>content.proton.executor.warmup.utilization</td>
	  <td>Ratio of time the executor warmup worker threads has been active</td>
	  <td>fraction</td>
	  <td>max, sum, count</td>
	</tr>
	<tr>
	  <td>content.proton.executor.field_writer.queuesize</td>
	  <td>Size of executor field writer task queue</td>
	  <td>task</td>
	  <td>max, sum, count</td>
	</tr>
	<tr>
	  <td>content.proton.executor.field_writer.accepted</td>
	  <td>Number of accepted executor field writer tasks</td>
	  <td>task</td>
	  <td>rate</td>
	</tr>
	<tr>
	  <td>content.proton.executor.field_writer.wakeups</td>
	  <td>Number of times a executor field writer worker thread has been woken up</td>
	  <td>wakeup</td>
	  <td>rate</td>
	</tr>
	<tr>
	  <td>content.proton.executor.field_writer.utilization</td>
	  <td>Ratio of time the executor fieldwriter worker threads has been active</td>
	  <td>fraction</td>
	  <td>max, sum, count</td>
	</tr>
	<tr>
	  <td>content.proton.documentdb.job.total</td>
	  <td>The job load average total of all job metrics</td>
	  <td>fraction</td>
	  <td>average</td>
	</tr>
	<tr>
	  <td>content.proton.documentdb.job.attribute_flush</td>
	  <td>Flushing of attribute vector(s) to disk</td>
	  <td>fraction</td>
	  <td>average</td>
	</tr>
	<tr>
	  <td>content.proton.documentdb.job.memory_index_flush</td>
	  <td>Flushing of memory index to disk</td>
	  <td>fraction</td>
	  <td>average</td>
	</tr>
	<tr>
	  <td>content.proton.documentdb.job.disk_index_fusion</td>
	  <td>Fusion of disk indexes</td>
	  <td>fraction</td>
	  <td>average</td>
	</tr>
	<tr>
	  <td>content.proton.documentdb.job.document_store_flush</td>
	  <td>Flushing of document store to disk</td>
	  <td>fraction</td>
	  <td>average</td>
	</tr>
	<tr>
	  <td>content.proton.documentdb.job.document_store_compact</td>
	  <td>Compaction of document store on disk</td>
	  <td>fraction</td>
	  <td>average</td>
	</tr>
	<tr>
	  <td>content.proton.documentdb.job.bucket_move</td>
	  <td>Moving of buckets between 'ready' and 'notready' sub databases</td>
	  <td>fraction</td>
	  <td>average</td>
	</tr>
	<tr>
	  <td>content.proton.documentdb.job.lid_space_compact</td>
	  <td>Compaction of lid space in document meta store and attribute vectors</td>
	  <td>fraction</td>
	  <td>average</td>
	</tr>
	<tr>
	  <td>content.proton.documentdb.job.removed_documents_prune</td>
	  <td>Pruning of removed documents in 'removed' sub database</td>
	  <td>fraction</td>
	  <td>average</td>
	</tr>
	<tr>
	  <td>content.proton.documentdb.threading_service.master.queuesize</td>
	  <td>Size of threading service master task queue</td>
	  <td>task</td>
	  <td>max, sum, count</td>
	</tr>
	<tr>
	  <td>content.proton.documentdb.threading_service.master.accepted</td>
	  <td>Number of accepted threading service master tasks</td>
	  <td>task</td>
	  <td>rate</td>
	</tr>
	<tr>
	  <td>content.proton.documentdb.threading_service.master.wakeups</td>
	  <td>Number of times a threading service master worker thread has been woken up</td>
	  <td>wakeup</td>
	  <td>rate</td>
	</tr>
	<tr>
	  <td>content.proton.documentdb.threading_service.master.utilization</td>
	  <td>Ratio of time the threading service master worker threads has been active</td>
	  <td>fraction</td>
	  <td>max, sum, count</td>
	</tr>
	<tr>
	  <td>content.proton.documentdb.threading_service.index.queuesize</td>
	  <td>Size of threading service index task queue</td>
	  <td>task</td>
	  <td>max, sum, count</td>
	</tr>
	<tr>
	  <td>content.proton.documentdb.threading_service.index.accepted</td>
	  <td>Number of accepted threading service index tasks</td>
	  <td>task</td>
	  <td>rate</td>
	</tr>
	<tr>
	  <td>content.proton.documentdb.threading_service.index.wakeups</td>
	  <td>Number of times a threading service index worker thread has been woken up</td>
	  <td>wakeup</td>
	  <td>rate</td>
	</tr>
	<tr>
	  <td>content.proton.documentdb.threading_service.index.utilization</td>
	  <td>Ratio of time the threading service index worker threads has been active</td>
	  <td>fraction</td>
	  <td>max, sum, count</td>
	</tr>
	<tr>
	  <td>content.proton.documentdb.threading_service.summary.queuesize</td>
	  <td>Size of threading service summary task queue</td>
	  <td>task</td>
	  <td>max, sum, count</td>
	</tr>
	<tr>
	  <td>content.proton.documentdb.threading_service.summary.accepted</td>
	  <td>Number of accepted threading service summary tasks</td>
	  <td>task</td>
	  <td>rate</td>
	</tr>
	<tr>
	  <td>content.proton.documentdb.threading_service.summary.wakeups</td>
	  <td>Number of times a threading service summary worker thread has been woken up</td>
	  <td>wakeup</td>
	  <td>rate</td>
	</tr>
	<tr>
	  <td>content.proton.documentdb.threading_service.summary.utilization</td>
	  <td>Ratio of time the threading service summary worker threads has been active</td>
	  <td>fraction</td>
	  <td>max, sum, count</td>
	</tr>
	<tr>
	  <td>content.proton.documentdb.ready.lid_space.lid_bloat_factor</td>
	  <td>The bloat factor of this lid space, indicating the total amount of holes in the allocated lid space ((lid_limit - used_lids) / lid_limit)</td>
	  <td>fraction</td>
	  <td>average</td>
	</tr>
	<tr>
	  <td>content.proton.documentdb.ready.lid_space.lid_fragmentation_factor</td>
	  <td>The fragmentation factor of this lid space, indicating the amount of holes in the currently used part of the lid space ((highest_used_lid - used_lids) / highest_used_lid)</td>
	  <td>fraction</td>
	  <td>average</td>
	</tr>
	<tr>
	  <td>content.proton.documentdb.ready.lid_space.lid_limit</td>
	  <td>The size of the allocated lid space</td>
	  <td>documentid</td>
	  <td>last</td>
	</tr>
	<tr>
	  <td>content.proton.documentdb.ready.lid_space.highest_used_lid</td>
	  <td>The highest used lid</td>
	  <td>documentid</td>
	  <td>last</td>
	</tr>
	<tr>
	  <td>content.proton.documentdb.ready.lid_space.used_lids</td>
	  <td>The number of lids used</td>
	  <td>documentid</td>
	  <td>last</td>
	</tr>
	<tr>
	  <td>content.proton.documentdb.notready.lid_space.lid_bloat_factor</td>
	  <td>The bloat factor of this lid space, indicating the total amount of holes in the allocated lid space ((lid_limit - used_lids) / lid_limit)</td>
	  <td>fraction</td>
	  <td>average</td>
	</tr>
	<tr>
	  <td>content.proton.documentdb.notready.lid_space.lid_fragmentation_factor</td>
	  <td>The fragmentation factor of this lid space, indicating the amount of holes in the currently used part of the lid space ((highest_used_lid - used_lids) / highest_used_lid)</td>
	  <td>fraction</td>
	  <td>average</td>
	</tr>
	<tr>
	  <td>content.proton.documentdb.notready.lid_space.lid_limit</td>
	  <td>The size of the allocated lid space</td>
	  <td>documentid</td>
	  <td>last</td>
	</tr>
	<tr>
	  <td>content.proton.documentdb.notready.lid_space.highest_used_lid</td>
	  <td>The highest used lid</td>
	  <td>documentid</td>
	  <td>last</td>
	</tr>
	<tr>
	  <td>content.proton.documentdb.notready.lid_space.used_lids</td>
	  <td>The number of lids used</td>
	  <td>documentid</td>
	  <td>last</td>
	</tr>
	<tr>
	  <td>content.proton.documentdb.removed.lid_space.lid_bloat_factor</td>
	  <td>The bloat factor of this lid space, indicating the total amount of holes in the allocated lid space ((lid_limit - used_lids) / lid_limit)</td>
	  <td>fraction</td>
	  <td>average</td>
	</tr>
	<tr>
	  <td>content.proton.documentdb.removed.lid_space.lid_fragmentation_factor</td>
	  <td>The fragmentation factor of this lid space, indicating the amount of holes in the currently used part of the lid space ((highest_used_lid - used_lids) / highest_used_lid)</td>
	  <td>fraction</td>
	  <td>average</td>
	</tr>
	<tr>
	  <td>content.proton.documentdb.removed.lid_space.lid_limit</td>
	  <td>The size of the allocated lid space</td>
	  <td>documentid</td>
	  <td>last</td>
	</tr>
	<tr>
	  <td>content.proton.documentdb.removed.lid_space.highest_used_lid</td>
	  <td>The highest used lid</td>
	  <td>documentid</td>
	  <td>last</td>
	</tr>
	<tr>
	  <td>content.proton.documentdb.removed.lid_space.used_lids</td>
	  <td>The number of lids used</td>
	  <td>documentid</td>
	  <td>last</td>
	</tr>
	<tr>
	  <td>content.proton.documentdb.bucket_move.buckets_pending</td>
	  <td>The number of buckets left to move</td>
	  <td>bucket</td>
	  <td>last</td>
	</tr>
	<tr>
	  <td>content.proton.resource_usage.disk</td>
	  <td>The relative amount of disk used by this content node (transient usage not included, value in the range [0, 1]). Same value as reported to the cluster controller</td>
	  <td>fraction</td>
	  <td>average</td>
	</tr>
	<tr>
	  <td>content.proton.resource_usage.disk_usage.total</td>
	  <td>The total relative amount of disk used by this content node (value in the range [0, 1])</td>
	  <td>fraction</td>
	  <td>max</td>
	</tr>
	<tr>
	  <td>content.proton.resource_usage.disk_usage.total_utilization</td>
	  <td>The relative amount of disk used compared to the content node disk resource limit</td>
	  <td>fraction</td>
	  <td>max</td>
	</tr>
	<tr>
	  <td>content.proton.resource_usage.disk_usage.transient</td>
	  <td>The relative amount of transient disk used by this content node (value in the range [0, 1])</td>
	  <td>fraction</td>
	  <td>max</td>
	</tr>
	<tr>
	  <td>content.proton.resource_usage.memory</td>
	  <td>The relative amount of memory used by this content node (transient usage not included, value in the range [0, 1]). Same value as reported to the cluster controller</td>
	  <td>fraction</td>
	  <td>average</td>
	</tr>
	<tr>
	  <td>content.proton.resource_usage.memory_usage.total</td>
	  <td>The total relative amount of memory used by this content node (value in the range [0, 1])</td>
	  <td>fraction</td>
	  <td>max</td>
	</tr>
	<tr>
	  <td>content.proton.resource_usage.memory_usage.total_utilization</td>
	  <td>The relative amount of memory used compared to the content node memory resource limit</td>
	  <td>fraction</td>
	  <td>max</td>
	</tr>
	<tr>
	  <td>content.proton.resource_usage.memory_usage.transient</td>
	  <td>The relative amount of transient memory used by this content node (value in the range [0, 1])</td>
	  <td>fraction</td>
	  <td>max</td>
	</tr>
	<tr>
	  <td>content.proton.resource_usage.memory_mappings</td>
	  <td>The number of mapped memory areas</td>
	  <td>area</td>
	  <td>max</td>
	</tr>
	<tr>
	  <td>content.proton.resource_usage.open_file_descriptors</td>
	  <td>The number of open files</td>
	  <td>file</td>
	  <td>max</td>
	</tr>
	<tr>
	  <td>content.proton.resource_usage.feeding_blocked</td>
	  <td>Whether feeding is blocked due to resource limits being reached (value is either 0 or 1)</td>
	  <td>binary</td>
	  <td>max</td>
	</tr>
	<tr>
	  <td>content.proton.resource_usage.malloc_arena</td>
	  <td>Size of malloc arena</td>
	  <td>byte</td>
	  <td>max</td>
	</tr>
	<tr>
	  <td>content.proton.documentdb.attribute.resource_usage.address_space</td>
	  <td>The max relative address space used among components in all attribute vectors in this document db (value in the range [0, 1])</td>
	  <td>fraction</td>
	  <td>max</td>
	</tr>
	<tr>
	  <td>content.proton.documentdb.attribute.resource_usage.feeding_blocked</td>
	  <td>Whether feeding is blocked due to attribute resource limits being reached (value is either 0 or 1)</td>
	  <td>binary</td>
	  <td>max</td>
	</tr>
	<tr>
	  <td>content.proton.resource_usage.cpu_util.setup</td>
	  <td>cpu used by system init and (re-)configuration</td>
	  <td>fraction</td>
	  <td>max, sum, count</td>
	</tr>
	<tr>
	  <td>content.proton.resource_usage.cpu_util.read</td>
	  <td>cpu used by reading data from the system</td>
	  <td>fraction</td>
	  <td>max, sum, count</td>
	</tr>
	<tr>
	  <td>content.proton.resource_usage.cpu_util.write</td>
	  <td>cpu used by writing data to the system</td>
	  <td>fraction</td>
	  <td>max, sum, count</td>
	</tr>
	<tr>
	  <td>content.proton.resource_usage.cpu_util.compact</td>
	  <td>cpu used by internal data re-structuring</td>
	  <td>fraction</td>
	  <td>max, sum, count</td>
	</tr>
	<tr>
	  <td>content.proton.resource_usage.cpu_util.other</td>
	  <td>cpu used by work not classified as a specific category</td>
	  <td>fraction</td>
	  <td>max, sum, count</td>
	</tr>
	<tr>
	  <td>content.proton.transactionlog.entries</td>
	  <td>The current number of entries in the transaction log</td>
	  <td>record</td>
	  <td>average</td>
	</tr>
	<tr>
	  <td>content.proton.transactionlog.disk_usage</td>
	  <td>The disk usage (in bytes) of the transaction log</td>
	  <td>byte</td>
	  <td>average</td>
	</tr>
	<tr>
	  <td>content.proton.transactionlog.replay_time</td>
	  <td>The replay time (in seconds) of the transaction log during start-up</td>
	  <td>second</td>
	  <td>last</td>
	</tr>
	<tr>
	  <td>content.proton.documentdb.ready.document_store.disk_usage</td>
	  <td>Disk space usage in bytes</td>
	  <td>byte</td>
	  <td>average</td>
	</tr>
	<tr>
	  <td>content.proton.documentdb.ready.document_store.disk_bloat</td>
	  <td>Disk space bloat in bytes</td>
	  <td>byte</td>
	  <td>average</td>
	</tr>
	<tr>
	  <td>content.proton.documentdb.ready.document_store.max_bucket_spread</td>
	  <td>Max bucket spread in underlying files (sum(unique buckets in each chunk)/unique buckets in file)</td>
	  <td>fraction</td>
	  <td>average</td>
	</tr>
	<tr>
	  <td>content.proton.documentdb.ready.document_store.memory_usage.allocated_bytes</td>
	  <td>The number of allocated bytes</td>
	  <td>byte</td>
	  <td>average</td>
	</tr>
	<tr>
	  <td>content.proton.documentdb.ready.document_store.memory_usage.used_bytes</td>
	  <td>The number of used bytes (<= allocated_bytes)</td>
	  <td>byte</td>
	  <td>average</td>
	</tr>
	<tr>
	  <td>content.proton.documentdb.ready.document_store.memory_usage.onhold_bytes</td>
	  <td>The number of bytes on hold</td>
	  <td>byte</td>
	  <td>average</td>
	</tr>
	<tr>
	  <td>content.proton.documentdb.notready.document_store.disk_usage</td>
	  <td>Disk space usage in bytes</td>
	  <td>byte</td>
	  <td>average</td>
	</tr>
	<tr>
	  <td>content.proton.documentdb.notready.document_store.disk_bloat</td>
	  <td>Disk space bloat in bytes</td>
	  <td>byte</td>
	  <td>average</td>
	</tr>
	<tr>
	  <td>content.proton.documentdb.notready.document_store.max_bucket_spread</td>
	  <td>Max bucket spread in underlying files (sum(unique buckets in each chunk)/unique buckets in file)</td>
	  <td>fraction</td>
	  <td>average</td>
	</tr>
	<tr>
	  <td>content.proton.documentdb.notready.document_store.memory_usage.allocated_bytes</td>
	  <td>The number of allocated bytes</td>
	  <td>byte</td>
	  <td>average</td>
	</tr>
	<tr>
	  <td>content.proton.documentdb.notready.document_store.memory_usage.used_bytes</td>
	  <td>The number of used bytes (<= allocated_bytes)</td>
	  <td>byte</td>
	  <td>average</td>
	</tr>
	<tr>
	  <td>content.proton.documentdb.notready.document_store.memory_usage.dead_bytes</td>
	  <td>The number of dead bytes (<= used_bytes)</td>
	  <td>byte</td>
	  <td>average</td>
	</tr>
	<tr>
	  <td>content.proton.documentdb.notready.document_store.memory_usage.onhold_bytes</td>
	  <td>The number of bytes on hold</td>
	  <td>byte</td>
	  <td>average</td>
	</tr>
	<tr>
	  <td>content.proton.documentdb.removed.document_store.disk_usage</td>
	  <td>Disk space usage in bytes</td>
	  <td>byte</td>
	  <td>average</td>
	</tr>
	<tr>
	  <td>content.proton.documentdb.removed.document_store.disk_bloat</td>
	  <td>Disk space bloat in bytes</td>
	  <td>byte</td>
	  <td>average</td>
	</tr>
	<tr>
	  <td>content.proton.documentdb.removed.document_store.max_bucket_spread</td>
	  <td>Max bucket spread in underlying files (sum(unique buckets in each chunk)/unique buckets in file)</td>
	  <td>fraction</td>
	  <td>average</td>
	</tr>
	<tr>
	  <td>content.proton.documentdb.removed.document_store.memory_usage.allocated_bytes</td>
	  <td>The number of allocated bytes</td>
	  <td>byte</td>
	  <td>average</td>
	</tr>
	<tr>
	  <td>content.proton.documentdb.removed.document_store.memory_usage.used_bytes</td>
	  <td>The number of used bytes (<= allocated_bytes)</td>
	  <td>byte</td>
	  <td>average</td>
	</tr>
	<tr>
	  <td>content.proton.documentdb.removed.document_store.memory_usage.dead_bytes</td>
	  <td>The number of dead bytes (<= used_bytes)</td>
	  <td>byte</td>
	  <td>average</td>
	</tr>
	<tr>
	  <td>content.proton.documentdb.removed.document_store.memory_usage.onhold_bytes</td>
	  <td>The number of bytes on hold</td>
	  <td>byte</td>
	  <td>average</td>
	</tr>
	<tr>
	  <td>content.proton.documentdb.ready.document_store.cache.memory_usage</td>
	  <td>Memory usage of the cache (in bytes)</td>
	  <td>byte</td>
	  <td>average</td>
	</tr>
	<tr>
	  <td>content.proton.documentdb.ready.document_store.cache.hit_rate</td>
	  <td>Rate of hits in the cache compared to number of lookups</td>
	  <td>fraction</td>
	  <td>average</td>
	</tr>
	<tr>
	  <td>content.proton.documentdb.ready.document_store.cache.lookups</td>
	  <td>Number of lookups in the cache (hits + misses)</td>
	  <td>operation</td>
	  <td>rate</td>
	</tr>
	<tr>
	  <td>content.proton.documentdb.ready.document_store.cache.invalidations</td>
	  <td>Number of invalidations (erased elements) in the cache. </td>
	  <td>operation</td>
	  <td>rate</td>
	</tr>
	<tr>
	  <td>content.proton.documentdb.notready.document_store.cache.memory_usage</td>
	  <td>Memory usage of the cache (in bytes)</td>
	  <td>byte</td>
	  <td>average</td>
	</tr>
	<tr>
	  <td>content.proton.documentdb.notready.document_store.cache.hit_rate</td>
	  <td>Rate of hits in the cache compared to number of lookups</td>
	  <td>fraction</td>
	  <td>average</td>
	</tr>
	<tr>
	  <td>content.proton.documentdb.notready.document_store.cache.lookups</td>
	  <td>Number of lookups in the cache (hits + misses)</td>
	  <td>operation</td>
	  <td>rate</td>
	</tr>
	<tr>
	  <td>content.proton.documentdb.notready.document_store.cache.invalidations</td>
	  <td>Number of invalidations (erased elements) in the cache. </td>
	  <td>operation</td>
	  <td>rate</td>
	</tr>
	<tr>
	  <td>content.proton.documentdb.ready.attribute.memory_usage.allocated_bytes</td>
	  <td>The number of allocated bytes</td>
	  <td>byte</td>
	  <td>average</td>
	</tr>
	<tr>
	  <td>content.proton.documentdb.ready.attribute.memory_usage.used_bytes</td>
	  <td>The number of used bytes (<= allocated_bytes)</td>
	  <td>byte</td>
	  <td>average</td>
	</tr>
	<tr>
	  <td>content.proton.documentdb.ready.attribute.memory_usage.dead_bytes</td>
	  <td>The number of dead bytes (<= used_bytes)</td>
	  <td>byte</td>
	  <td>average</td>
	</tr>
	<tr>
	  <td>content.proton.documentdb.ready.attribute.memory_usage.onhold_bytes</td>
	  <td>The number of bytes on hold</td>
	  <td>byte</td>
	  <td>average</td>
	</tr>
	<tr>
	  <td>content.proton.documentdb.notready.attribute.memory_usage.allocated_bytes</td>
	  <td>The number of allocated bytes</td>
	  <td>byte</td>
	  <td>average</td>
	</tr>
	<tr>
	  <td>content.proton.documentdb.notready.attribute.memory_usage.used_bytes</td>
	  <td>The number of used bytes (<= allocated_bytes)</td>
	  <td>byte</td>
	  <td>average</td>
	</tr>
	<tr>
	  <td>content.proton.documentdb.notready.attribute.memory_usage.dead_bytes</td>
	  <td>The number of dead bytes (<= used_bytes)</td>
	  <td>byte</td>
	  <td>average</td>
	</tr>
	<tr>
	  <td>content.proton.documentdb.notready.attribute.memory_usage.onhold_bytes</td>
	  <td>The number of bytes on hold</td>
	  <td>byte</td>
	  <td>average</td>
	</tr>
	<tr>
	  <td>content.proton.documentdb.index.memory_usage.allocated_bytes</td>
	  <td>The number of allocated bytes</td>
	  <td>byte</td>
	  <td>average</td>
	</tr>
	<tr>
	  <td>content.proton.documentdb.index.memory_usage.used_bytes</td>
	  <td>The number of used bytes (<= allocated_bytes)</td>
	  <td>byte</td>
	  <td>average</td>
	</tr>
	<tr>
	  <td>content.proton.documentdb.index.memory_usage.dead_bytes</td>
	  <td>The number of dead bytes (<= used_bytes)</td>
	  <td>byte</td>
	  <td>average</td>
	</tr>
	<tr>
	  <td>content.proton.documentdb.index.memory_usage.onhold_bytes</td>
	  <td>The number of bytes on hold</td>
	  <td>byte</td>
	  <td>average</td>
	</tr>
	<tr>
	  <td>content.proton.documentdb.matching.queries</td>
	  <td>Number of queries executed</td>
	  <td>query</td>
	  <td>rate</td>
	</tr>
	<tr>
	  <td>content.proton.documentdb.matching.soft_doomed_queries</td>
	  <td>Number of queries hitting the soft timeout</td>
	  <td>query</td>
	  <td>rate</td>
	</tr>
	<tr>
	  <td>content.proton.documentdb.matching.query_latency</td>
	  <td>Total average latency (sec) when matching and ranking a query</td>
	  <td>second</td>
	  <td>max, sum, count</td>
	</tr>
	<tr>
	  <td>content.proton.documentdb.matching.query_setup_time</td>
	  <td>Average time (sec) spent setting up and tearing down queries</td>
	  <td>second</td>
	  <td>max, sum, count</td>
	</tr>
	<tr>
	  <td>content.proton.documentdb.matching.docs_matched</td>
	  <td>Number of documents matched</td>
	  <td>document</td>
	  <td>rate, count</td>
	</tr>
	<tr>
	  <td>content.proton.documentdb.matching.rank_profile.queries</td>
	  <td>Number of queries executed</td>
	  <td>query</td>
	  <td>rate</td>
	</tr>
	<tr>
	  <td>content.proton.documentdb.matching.rank_profile.soft_doomed_queries</td>
	  <td>Number of queries hitting the soft timeout</td>
	  <td>query</td>
	  <td>rate</td>
	</tr>
	<tr>
	  <td>content.proton.documentdb.matching.rank_profile.soft_doom_factor</td>
	  <td>Factor used to compute soft-timeout</td>
	  <td>fraction</td>
	  <td>min, max, sum, count</td>
	</tr>
	<tr>
	  <td>content.proton.documentdb.matching.rank_profile.query_latency</td>
	  <td>Total average latency (sec) when matching and ranking a query</td>
	  <td>second</td>
	  <td>max, sum, count</td>
	</tr>
	<tr>
	  <td>content.proton.documentdb.matching.rank_profile.query_setup_time</td>
	  <td>Average time (sec) spent setting up and tearing down queries</td>
	  <td>second</td>
	  <td>max, sum, count</td>
	</tr>
	<tr>
	  <td>content.proton.documentdb.matching.rank_profile.grouping_time</td>
	  <td>Average time (sec) spent on grouping</td>
	  <td>second</td>
	  <td>max, sum, count</td>
	</tr>
	<tr>
	  <td>content.proton.documentdb.matching.rank_profile.rerank_time</td>
	  <td>Average time (sec) spent on 2nd phase ranking</td>
	  <td>second</td>
	  <td>max, sum, count</td>
	</tr>
	<tr>
	  <td>content.proton.documentdb.matching.rank_profile.docs_matched</td>
	  <td>Number of documents matched</td>
	  <td>document</td>
	  <td>rate, count</td>
	</tr>
	<tr>
	  <td>content.proton.documentdb.matching.rank_profile.limited_queries</td>
	  <td>Number of queries limited in match phase</td>
	  <td>query</td>
	  <td>rate</td>
	</tr>
	<tr>
	  <td>content.proton.documentdb.feeding.commit.operations</td>
	  <td>Number of operations included in a commit</td>
	  <td>operation</td>
	  <td>max, sum, count, rate</td>
	</tr>
	<tr>
	  <td>content.proton.documentdb.feeding.commit.latency</td>
	  <td>Latency for commit in seconds</td>
	  <td>second</td>
	  <td>max, sum, count</td>
	</tr>
    </tbody>
</table>

<h2 id=sentinel-metrics>Sentinel Metrics</h2>
<table class="table">
    <thead>
        <tr><th>Name</th><th>Description</th><th>Unit</th><th>Suffixes</th></tr>
    </thead>
    <tbody>
	<tr>
	  <td>sentinel.restarts</td>
	  <td>Number of service restarts done by the sentinel</td>
	  <td>restart</td>
	  <td>count</td>
	</tr>
	<tr>
	  <td>sentinel.totalRestarts</td>
	  <td>Total number of service restarts done by the sentinel since the sentinel was started</td>
	  <td>restart</td>
	  <td>last</td>
	</tr>
	<tr>
	  <td>sentinel.uptime</td>
	  <td>Time  the sentinel has been running</td>
	  <td>second</td>
	  <td>last</td>
	</tr>
	<tr>
	  <td>sentinel.running</td>
	  <td>Number of services the sentinel has running currently</td>
	  <td>instance</td>
	  <td>count, last</td>
	</tr>
    </tbody>
</table>

<h2 id=slobrok-metrics>Slobrok Metrics</h2>
<table class="table">
    <thead>
        <tr><th>Name</th><th>Description</th><th>Unit</th><th>Suffixes</th></tr>
    </thead>
    <tbody>
	<tr>
	  <td>slobrok.heartbeats.failed</td>
	  <td>Number of heartbeat requests failed</td>
	  <td>request</td>
	  <td>count</td>
	</tr>
	<tr>
	  <td>slobrok.missing.consensus</td>
	  <td>Number of seconds without full consensus with all other brokers</td>
	  <td>second</td>
	  <td>count</td>
	</tr>
    </tbody>
</table>

<h2 id=storage-metrics>Storage Metrics</h2>
<table class="table">
    <thead>
        <tr><th>Name</th><th>Description</th><th>Unit</th><th>Suffixes</th></tr>
    </thead>
    <tbody>
	<tr>
	  <td>vds.server.network.tls-handshakes-failed</td>
	  <td>Number of client or server connection attempts that failed during TLS handshaking</td>
	  <td>operation</td>
	  <td>count</td>
	</tr>
	<tr>
	  <td>vds.server.network.peer-authorization-failures</td>
	  <td>Number of TLS connection attempts failed due to bad or missing peer certificate credentials</td>
	  <td>failure</td>
	  <td>count</td>
	</tr>
	<tr>
	  <td>vds.server.network.client.tls-connections-established</td>
	  <td>Number of secure mTLS connections established</td>
	  <td>connection</td>
	  <td>count</td>
	</tr>
	<tr>
	  <td>vds.server.network.server.tls-connections-established</td>
	  <td>Number of secure mTLS connections established</td>
	  <td>connection</td>
	  <td>count</td>
	</tr>
	<tr>
	  <td>vds.server.network.client.insecure-connections-established</td>
	  <td>Number of insecure (plaintext) connections established</td>
	  <td>connection</td>
	  <td>count</td>
	</tr>
	<tr>
	  <td>vds.server.network.server.insecure-connections-established</td>
	  <td>Number of insecure (plaintext) connections established</td>
	  <td>connection</td>
	  <td>count</td>
	</tr>
	<tr>
	  <td>vds.server.network.tls-connections-broken</td>
	  <td>Number of TLS connections broken due to failures during frame encoding or decoding</td>
	  <td>connection</td>
	  <td>count</td>
	</tr>
	<tr>
	  <td>vds.server.network.failed-tls-config-reloads</td>
	  <td>Number of times background reloading of TLS config has failed</td>
	  <td>failure</td>
	  <td>count</td>
	</tr>
	<tr>
	  <td>vds.server.network.rpc-capability-checks-failed</td>
	  <td>Number of RPC operations that failed to due one or more missing capabilities</td>
	  <td>failure</td>
	  <td>count</td>
	</tr>
	<tr>
	  <td>vds.server.network.status-capability-checks-failed</td>
	  <td>Number of status page operations that failed to due one or more missing capabilities</td>
	  <td>failure</td>
	  <td>count</td>
	</tr>
	<tr>
	  <td>vds.server.fnet.num-connections</td>
	  <td>Total number of connection objects</td>
	  <td>connection</td>
	  <td>count</td>
	</tr>
	<tr>
	  <td>vds.datastored.alldisks.buckets</td>
	  <td>Number of buckets managed</td>
	  <td>bucket</td>
	  <td>average</td>
	</tr>
	<tr>
	  <td>vds.datastored.alldisks.docs</td>
	  <td>Number of documents stored</td>
	  <td>document</td>
	  <td>average</td>
	</tr>
	<tr>
	  <td>vds.datastored.alldisks.bytes</td>
	  <td>Number of bytes stored</td>
	  <td>byte</td>
	  <td>average</td>
	</tr>
	<tr>
	  <td>vds.visitor.allthreads.averagevisitorlifetime</td>
	  <td>Average lifetime of a visitor</td>
	  <td>millisecond</td>
	  <td>max, sum, count</td>
	</tr>
	<tr>
	  <td>vds.visitor.allthreads.averagequeuewait</td>
	  <td>Average time an operation spends in input queue.</td>
	  <td>millisecond</td>
	  <td>max, sum, count</td>
	</tr>
	<tr>
	  <td>vds.visitor.allthreads.queuesize</td>
	  <td>Size of input message queue.</td>
	  <td>operation</td>
	  <td>max, sum, count</td>
	</tr>
	<tr>
	  <td>vds.visitor.allthreads.completed</td>
	  <td>Number of visitors completed</td>
	  <td>operation</td>
	  <td>rate</td>
	</tr>
	<tr>
	  <td>vds.visitor.allthreads.created</td>
	  <td>Number of visitors created.</td>
	  <td>operation</td>
	  <td>rate</td>
	</tr>
	<tr>
	  <td>vds.visitor.allthreads.failed</td>
	  <td>Number of visitors failed</td>
	  <td>operation</td>
	  <td>rate</td>
	</tr>
	<tr>
	  <td>vds.visitor.allthreads.averagemessagesendtime</td>
	  <td>Average time it takes for messages to be sent to their target (and be replied to)</td>
	  <td>millisecond</td>
	  <td>max, sum, count</td>
	</tr>
	<tr>
	  <td>vds.visitor.allthreads.averageprocessingtime</td>
	  <td>Average time used to process visitor requests</td>
	  <td>millisecond</td>
	  <td>max, sum, count</td>
	</tr>
	<tr>
	  <td>vds.filestor.queuesize</td>
	  <td>Size of input message queue.</td>
	  <td>operation</td>
	  <td>max, sum, count</td>
	</tr>
	<tr>
	  <td>vds.filestor.averagequeuewait</td>
	  <td>Average time an operation spends in input queue.</td>
	  <td>millisecond</td>
	  <td>max, sum, count</td>
	</tr>
	<tr>
	  <td>vds.filestor.active_operations.size</td>
	  <td>Number of concurrent active operations</td>
	  <td>operation</td>
	  <td>max, sum, count</td>
	</tr>
	<tr>
	  <td>vds.filestor.active_operations.latency</td>
	  <td>Latency (in ms) for completed operations</td>
	  <td>millisecond</td>
	  <td>max, sum, count</td>
	</tr>
	<tr>
	  <td>vds.filestor.throttle_window_size</td>
	  <td>Current size of async operation throttler window size</td>
	  <td>operation</td>
	  <td>max, sum, count</td>
	</tr>
	<tr>
	  <td>vds.filestor.throttle_waiting_threads</td>
	  <td>Number of threads waiting to acquire a throttle token</td>
	  <td>thread</td>
	  <td>max, sum, count</td>
	</tr>
	<tr>
	  <td>vds.filestor.throttle_active_tokens</td>
	  <td>Current number of active throttle tokens</td>
	  <td>instance</td>
	  <td>max, sum, count</td>
	</tr>
	<tr>
	  <td>vds.filestor.allthreads.mergemetadatareadlatency</td>
	  <td>Time spent in a merge step to check metadata of current node to see what data it has.</td>
	  <td>millisecond</td>
	  <td>max, sum, count</td>
	</tr>
	<tr>
	  <td>vds.filestor.allthreads.mergedatareadlatency</td>
	  <td>Time spent in a merge step to read data other nodes need.</td>
	  <td>millisecond</td>
	  <td>max, sum, count</td>
	</tr>
	<tr>
	  <td>vds.filestor.allthreads.mergedatawritelatency</td>
	  <td>Time spent in a merge step to write data needed to current node.</td>
	  <td>millisecond</td>
	  <td>max, sum, count</td>
	</tr>
	<tr>
	  <td>vds.filestor.allthreads.put_latency</td>
	  <td>Latency of individual puts that are part of merge operations</td>
	  <td>millisecond</td>
	  <td>max, sum, count</td>
	</tr>
	<tr>
	  <td>vds.filestor.allthreads.remove_latency</td>
	  <td>Latency of individual removes that are part of merge operations</td>
	  <td>millisecond</td>
	  <td>max, sum, count</td>
	</tr>
	<tr>
	  <td>vds.filestor.allstripes.throttled_rpc_direct_dispatches</td>
	  <td>Number of times an RPC thread could not directly dispatch an async operation directly to Proton because it was disallowed by the throttle policy</td>
	  <td>instance</td>
	  <td>rate</td>
	</tr>
	<tr>
	  <td>vds.filestor.allstripes.throttled_persistence_thread_polls</td>
	  <td>Number of times a persistence thread could not immediately dispatch a queued async operation because it was disallowed by the throttle policy</td>
	  <td>instance</td>
	  <td>rate</td>
	</tr>
	<tr>
	  <td>vds.filestor.allstripes.timeouts_waiting_for_throttle_token</td>
	  <td>Number of times a persistence thread timed out waiting for an available throttle policy token</td>
	  <td>instance</td>
	  <td>rate</td>
	</tr>
	<tr>
	  <td>vds.filestor.allthreads.put.count</td>
	  <td>Number of requests processed.</td>
	  <td>operation</td>
	  <td>rate</td>
	</tr>
	<tr>
	  <td>vds.filestor.allthreads.put.failed</td>
	  <td>Number of failed requests.</td>
	  <td>operation</td>
	  <td>rate</td>
	</tr>
	<tr>
	  <td>vds.filestor.allthreads.put.test_and_set_failed</td>
	  <td>Number of operations that were skipped due to a test-and-set condition not met</td>
	  <td>operation</td>
	  <td>rate</td>
	</tr>
	<tr>
	  <td>vds.filestor.allthreads.put.latency</td>
	  <td>Latency of successful requests.</td>
	  <td>millisecond</td>
	  <td>max, sum, count</td>
	</tr>
	<tr>
	  <td>vds.filestor.allthreads.put.request_size</td>
	  <td>Size of requests, in bytes</td>
	  <td>byte</td>
	  <td>max, sum, count</td>
	</tr>
	<tr>
	  <td>vds.filestor.allthreads.remove.count</td>
	  <td>Number of requests processed.</td>
	  <td>operation</td>
	  <td>rate</td>
	</tr>
	<tr>
	  <td>vds.filestor.allthreads.remove.failed</td>
	  <td>Number of failed requests.</td>
	  <td>operation</td>
	  <td>rate</td>
	</tr>
	<tr>
	  <td>vds.filestor.allthreads.remove.test_and_set_failed</td>
	  <td>Number of operations that were skipped due to a test-and-set condition not met</td>
	  <td>operation</td>
	  <td>rate</td>
	</tr>
	<tr>
	  <td>vds.filestor.allthreads.remove.latency</td>
	  <td>Latency of successful requests.</td>
	  <td>millisecond</td>
	  <td>max, sum, count</td>
	</tr>
	<tr>
	  <td>vds.filestor.allthreads.remove.request_size</td>
	  <td>Size of requests, in bytes</td>
	  <td>byte</td>
	  <td>max, sum, count</td>
	</tr>
	<tr>
	  <td>vds.filestor.allthreads.get.count</td>
	  <td>Number of requests processed.</td>
	  <td>operation</td>
	  <td>rate</td>
	</tr>
	<tr>
	  <td>vds.filestor.allthreads.get.failed</td>
	  <td>Number of failed requests.</td>
	  <td>operation</td>
	  <td>rate</td>
	</tr>
	<tr>
	  <td>vds.filestor.allthreads.get.latency</td>
	  <td>Latency of successful requests.</td>
	  <td>millisecond</td>
	  <td>max, sum, count</td>
	</tr>
	<tr>
	  <td>vds.filestor.allthreads.get.request_size</td>
	  <td>Size of requests, in bytes</td>
	  <td>byte</td>
	  <td>max, sum, count</td>
	</tr>
	<tr>
	  <td>vds.filestor.allthreads.update.count</td>
	  <td>Number of requests processed.</td>
	  <td>request</td>
	  <td>rate</td>
	</tr>
	<tr>
	  <td>vds.filestor.allthreads.update.failed</td>
	  <td>Number of failed requests.</td>
	  <td>request</td>
	  <td>rate</td>
	</tr>
	<tr>
	  <td>vds.filestor.allthreads.update.test_and_set_failed</td>
	  <td>Number of requests that were skipped due to a test-and-set condition not met</td>
	  <td>request</td>
	  <td>rate</td>
	</tr>
	<tr>
	  <td>vds.filestor.allthreads.update.latency</td>
	  <td>Latency of successful requests.</td>
	  <td>millisecond</td>
	  <td>max, sum, count</td>
	</tr>
	<tr>
	  <td>vds.filestor.allthreads.update.request_size</td>
	  <td>Size of requests, in bytes</td>
	  <td>byte</td>
	  <td>max, sum, count</td>
	</tr>
	<tr>
	  <td>vds.filestor.allthreads.createiterator.count</td>
	  <td>Number of requests processed.</td>
	  <td>request</td>
	  <td>rate</td>
	</tr>
	<tr>
	  <td>vds.filestor.allthreads.createiterator.latency</td>
	  <td>Latency of successful requests.</td>
	  <td>millisecond</td>
	  <td>max, sum, count</td>
	</tr>
	<tr>
	  <td>vds.filestor.allthreads.visit.count</td>
	  <td>Number of requests processed.</td>
	  <td>request</td>
	  <td>rate</td>
	</tr>
	<tr>
	  <td>vds.filestor.allthreads.visit.latency</td>
	  <td>Latency of successful requests.</td>
	  <td>millisecond</td>
	  <td>max, sum, count</td>
	</tr>
	<tr>
	  <td>vds.filestor.allthreads.remove_location.count</td>
	  <td>Number of requests processed.</td>
	  <td>request</td>
	  <td>rate</td>
	</tr>
	<tr>
	  <td>vds.filestor.allthreads.remove_location.latency</td>
	  <td>Latency of successful requests.</td>
	  <td>millisecond</td>
	  <td>max, sum, count</td>
	</tr>
	<tr>
	  <td>vds.filestor.allthreads.splitbuckets.count</td>
	  <td>Number of requests processed.</td>
	  <td>request</td>
	  <td>rate</td>
	</tr>
	<tr>
	  <td>vds.filestor.allthreads.joinbuckets.count</td>
	  <td>Number of requests processed.</td>
	  <td>request</td>
	  <td>rate</td>
	</tr>
	<tr>
	  <td>vds.filestor.allthreads.deletebuckets.count</td>
	  <td>Number of requests processed.</td>
	  <td>request</td>
	  <td>rate</td>
	</tr>
	<tr>
	  <td>vds.filestor.allthreads.deletebuckets.failed</td>
	  <td>Number of failed requests.</td>
	  <td>request</td>
	  <td>rate</td>
	</tr>
	<tr>
	  <td>vds.filestor.allthreads.deletebuckets.latency</td>
	  <td>Latency of successful requests.</td>
	  <td>millisecond</td>
	  <td>max, sum, count</td>
	</tr>
	<tr>
	  <td>vds.filestor.allthreads.setbucketstates.count</td>
	  <td>Number of requests processed.</td>
	  <td>request</td>
	  <td>rate</td>
	</tr>
	<tr>
	  <td>vds.mergethrottler.averagequeuewaitingtime</td>
	  <td>Time merges spent in the throttler queue</td>
	  <td>millisecond</td>
	  <td>max, sum, count</td>
	</tr>
	<tr>
	  <td>vds.mergethrottler.queuesize</td>
	  <td>Length of merge queue</td>
	  <td>instance</td>
	  <td>max, sum, count</td>
	</tr>
	<tr>
	  <td>vds.mergethrottler.active_window_size</td>
	  <td>Number of merges active within the pending window size</td>
	  <td>instance</td>
	  <td>max, sum, count</td>
	</tr>
	<tr>
	  <td>vds.mergethrottler.bounced_due_to_back_pressure</td>
	  <td>Number of merges bounced due to resource exhaustion back-pressure</td>
	  <td>instance</td>
	  <td>rate</td>
	</tr>
	<tr>
	  <td>vds.mergethrottler.locallyexecutedmerges.ok</td>
	  <td>The number of successful merges for 'locallyexecutedmerges'</td>
	  <td>instance</td>
	  <td>rate</td>
	</tr>
	<tr>
	  <td>vds.mergethrottler.mergechains.ok</td>
	  <td>The number of successful merges for 'mergechains'</td>
	  <td>operation</td>
	  <td>rate</td>
	</tr>
	<tr>
	  <td>vds.mergethrottler.mergechains.failures.busy</td>
	  <td>The number of merges that failed because the storage node was busy</td>
	  <td>operation</td>
	  <td>rate</td>
	</tr>
	<tr>
	  <td>vds.mergethrottler.mergechains.failures.total</td>
	  <td>Sum of all failures</td>
	  <td>operation</td>
	  <td>rate</td>
	</tr>
    </tbody>
</table>
