---
# Copyright Yahoo. Licensed under the terms of the Apache 2.0 license. See LICENSE in the project root.
title: "Metrics"
redirect_from:
- /documentation/reference/metrics.html
- /en/reference/metrics.html
---


<p>
  Metrics can be accessed aggregated on an application-level using
  <em><a href="../reference/metrics-v2.html#metrics-v2-values">/metrics/v2/values</a></em>
  or at node-level using either
  <em><a href="../reference/metrics-v1.html#metrics-v1-values">/metrics/v1/values</a></em> or
  <em><a href="../reference/prometheus-v1.html#prometheus-v1-values">/prometheus/v1/values</a></em>.
</p>



<h2 id="customizing-metric-sets">Customizing Metric Sets</h2>
<p>
  The aggregation metrics APIs will all return metrics from the
  <a href="https://github.com/DataDog/integrations-extras/blob/master/vespa/metadata.csv">default</a> metric set.
  While this should cover the most basic operational Vespa metrics, the set of metrics returned
  can be customized through the <em><a href="../reference/services-admin.html#metrics">metrics</a></em> section in
  <em><a href="../reference/services.html">services.xml</a></em>. You can control the metric set by either including a pre-defined
  <em><a href="../reference/services-admin.html#metric-set">metric-set</a></em> or configure a specific
  <em><a href="../reference/services-admin.html#metric">metric</a></em>. The latter way is also how you include any
  <a href="#metrics-from-custom-components">metrics from custom components</a>.
</p>
<p>
  Vespa comes with two pre-defined metric sets:
</p>
<table class="table">
  <thead>
  <tr>
    <td>Metric set ID</td>
    <td>Description</td>
  </tr>
  </thead>
  <tbody>
    <tr>
      <td>default</td>
      <td>
        The default <a href="https://github.com/DataDog/integrations-extras/blob/master/vespa/metadata.csv">set of metrics</a>
      </td>
    </tr>
    <tr>
      <td>vespa</td>
      <td>
        A <a href="https://github.com/vespa-engine/vespa/blob/master/config-model/src/main/java/com/yahoo/vespa/model/admin/monitoring/VespaMetricSet.java">comprehensive list of metrics</a>
        used to inspect low-level behavior of Vespa.
        {% include note.html content='This is a comprehensive set with a lot of metrics. See paragraph on cost below.' %}
      </td>
    </tr>
  </tbody>
</table>
<p>
  Since increasing the number of metrics returned by Vespa will increase both network data to transfer, computing
  resources required to process, and metrics storage cost, it is recommended to keep the set of metrics to what
  you need to monitor your application. Also note that when configuring your own metric set, you need to pass
  the ID of your <em><a href="../reference/services-admin.html#consumer">consumer</a></em> as GET parameter
  <em>?consumer=my-consumer</em> to the APIs above (e.g. <em>/metrics/v2/values?consumer=my-consumer</em>).
</p>
<p>
  Example:
</p>
<pre>
&lt;metrics&gt;
    &lt;consumer id=&quot;my-consumer&quot;&gt;
        &lt;metric-set id=&quot;default&quot; /&gt;
        &lt;metric id=&quot;vds.idealstate.garbage_collection.documents_removed.count&quot; /&gt;
    &lt;/consumer&gt;
&lt;/metrics&gt;
</pre>



<h2 id="jdisc-metrics-details">jdisc Metrics Details</h2>
<p>
    Many of the metrics relevant to monitor for your application are emitted from the
    <a href="../jdisc/index.html">jDisc container</a> since this is both the outward
    facing component and where any custom business logic is run. The sections below covers some of the specifics
    related to these metrics.
</p>

<h3 id="metrics-from-custom-components">Metrics from custom components</h3>
<ol>
  <li>
    Add a <a href="https://javadoc.io/doc/com.yahoo.vespa/container-core/latest/com/yahoo/metrics/simple/MetricReceiver.html">
    com.yahoo.metrics.simple.MetricReceiver</a>
    instance to the constructor of the component - it is injected by the container.
  </li>
  <li>
    Declare the <em>gauges</em> and <em>counters</em> using the <em>declare</em> methods on the metric receiver.
    Optionally set arbitrary metric dimensions to default values at declaration time - refer to the javadoc for details.
  </li>
  <li>
    Each time there is some data to measure,
    invoke the <em>sample</em> method on gauges or the <em>add</em> method on counters.
    When sampling data, any dimensions can optionally be set.
  </li>
</ol>
<p>
  The gauges and counters declared are inherently thread-safe. Example:
</p>
<pre>{% highlight java %}
package com.yahoo.example;

import java.util.Optional;
import com.yahoo.metrics.simple.Gauge;
import com.yahoo.metrics.simple.MetricSettings;
import com.yahoo.metrics.simple.MetricReceiver;
import com.yahoo.search.Query;
import com.yahoo.search.Result;
import com.yahoo.search.Searcher;
import com.yahoo.search.searchchain.Execution;

public class HitCountSearcher extends Searcher {
    private static final String LANGUAGE_DIMENSION_NAME = "query_language";
    private static final String EXAMPLE_METRIC_NAME = "example_hitcounts";
    private final Gauge hitCountMetric;

    public HitCountSearcher(MetricReceiver receiver) {
        this.hitCountMetric = receiver.declareGauge(EXAMPLE_METRIC_NAME, Optional.empty(),
                new MetricSettings.Builder().histogram(true).build());
    }

    @Override
    public Result search(Query query, Execution execution) {
        Result result = execution.search(query);
        hitCountMetric
            .sample(result.getTotalHitCount(),
                    hitCountMetric.builder()
                        .set(LANGUAGE_DIMENSION_NAME, query.getModel().getParsingLanguage().languageCode())
                        .build());
        return result;
    }
}
{% endhighlight %}</pre>
<p>
  Then look at the metrics where the new event <em>example_hitcounts</em> is available in the list of metrics.
  The histograms for the last five minutes of logged data are available as CSV per
  dimension at <em>http://host:port/state/v1/metrics/histograms</em>.
  In the example, that would include the estimated total hit counts for queries, grouped by language.
  The underlying implementation of the histograms is <a href="http://hdrhistogram.org/">HdrHistogram</a>,
  and the CSV is simply what that library generates itself.
</p>


<h3 id="container-metrics">Container Metrics</h3>
<p>
  A few metrics are emitted with under multiple names, for compatibility with different metrics frameworks.
</p>

<h4 id="generic-container-metrics">Generic Container Metrics</h4>
<p>
  These metrics are output for the server as a whole and are not specific to HTTP.
</p>
<table class="table">
  <thead>
  <tr>
    <th>Metric name</th><th>Description</th>
  </tr>
  </thead><tbody>
<tr>
  <td>serverStartedMillis</td>
  <td>Time since server started</td>
</tr><tr>
  <td>mem.heap.total</td>
  <td>Total heap size</td>
</tr><tr>
  <td>mem.heap.free</td>
  <td>Free heap size</td>
</tr><tr>
  <td>mem.heap.used</td>
  <td>Used heap size</td>
</tr>
</tbody>
</table>


<h4 id="thread-pool-metrics">Thread Pool Metrics</h4>
<p>
    Metrics for the container thread pools.
    The <code>jdisc.thread_pool.*</code> metrics have a dimension <code>threadpool</code> with thread pool name,
    e.g <em>default-pool</em> for the container's default thread pool.
    See <a href="../performance/container-tuning.html">Container Tuning</a> for details.
</p>
<table class="table">
    <thead>
    <tr><th>Metric name</th><th>Description</th></tr>
    </thead>
    <tbody>
    <tr>
        <td>jdisc.thread_pool.size</td>
        <td>Size of the thread pool</td>
    </tr><tr>
        <td>jdisc.thread_pool.active_threads</td>
        <td>Number of threads that are active</td>
    </tr><tr>
        <td>jdisc.thread_pool.max_allowed_size</td>
        <td>The maximum allowed number of threads in the pool</td>
    </tr><tr>
        <td>jdisc.thread_pool.rejected_tasks</td>
        <td>Number of tasks rejected by the thread pool</td>
    </tr><tr>
        <td>jdisc.thread_pool.unhandled_exceptions</td>
        <td>Number of exceptions thrown by tasks</td>
    </tr><tr>
        <td>jdisc.thread_pool.work_queue.capacity</td>
        <td>Capacity of the task queue</td>
    </tr><tr>
        <td>jdisc.thread_pool.work_queue.size</td>
        <td>Size of the task queue</td>
    </tr><tr>
        <td>jdisc.http.jetty.threadpool.thread.max</td>
        <td>Jetty thread pool: configured maximum number of threads</td>
    </tr><tr>
        <td>jdisc.http.jetty.threadpool.thread.min</td>
        <td>Jetty thread pool: configured minimum number of threads</td>
    </tr><tr>
        <td>jdisc.http.jetty.threadpool.thread.reserved</td>
        <td>Jetty thread pool: configured number of reserved threads or -1 for heuristic</td>
    </tr><tr>
        <td>jdisc.http.jetty.threadpool.thread.busy</td>
        <td>Jetty thread pool: number of threads executing internal and transient jobs</td>
    </tr><tr>
        <td>jdisc.http.jetty.threadpool.thread.total</td>
        <td>Jetty thread pool: current number of threads</td>
    </tr><tr>
        <td>jdisc.http.jetty.threadpool.queue.size</td>
        <td>Jetty thread pool: current size of the job queue</td>
    </tr>
    </tbody>
</table>


<h4 id="http-specific-metrics">HTTP Specific Metrics</h4>
<p>
    These are metrics specific for HTTP.
    Those metrics that are specific to a connector will have a dimension containing the TCP listen port.
</p>
<table class="table">
    <thead><tr><th>Metric name</th><th>Description</th></tr></thead>
        <tbody>
        <tr>
            <td>jdisc.http.requests.status</td>
            <td>Number of requests to the built-in status handler</td>
        </tr><tr>
            <td>http.status.1xx</td>
            <td>Number of responses with a 1xx status</td>
        </tr><tr>
            <td>http.status.2xx</td>
            <td>Number of responses with a 2xx status</td>
        </tr><tr>
            <td>http.status.3xx</td>
            <td>Number of responses with a 3xx status</td>
        </tr><tr>
            <td>http.status.4xx</td>
            <td>Number of responses with a 4xx status</td>
        </tr><tr>
            <td>http.status.5xx</td>
            <td>Number of responses with a 5xx status</td>
        </tr><tr>
            <td>serverNumConnections</td>
            <td>The total number of connections opened</td>
        </tr><tr>
            <td>serverNumOpenConnections</td>
            <td>The current number of open connections</td>
        </tr><tr>
            <td>serverConnectionsOpenMax</td>
            <td>The max number of open connections</td>
        </tr><tr>
            <td>serverConnectionDurationMean, -Max, -StdDev</td>
            <td>The mean/max/stddev of connection duration in ms</td>
        </tr><tr>
            <td>serverNumRequests, jdisc.http.requests</td>
            <td>Number of requests received by the connector</td>
        </tr><tr>
            <td>serverNumSuccessfulResponses</td>
            <td>Number of successful responses sent by the connector</td>
        </tr><tr>
            <td>serverNumFailedResponses</td>
            <td>Number of error responses sent by the connector</td>
        </tr><tr>
            <td>serverNumSuccessfulResponseWrites</td>
            <td>Number of HTTP response chunks that have been successfully written to the network.</td>
        </tr><tr>
            <td>serverNumFailedResponseWrites</td>
            <td>Number of HTTP response chunks that have not been successfully written to the network,
                due to some kind of I/O error.</td>
        </tr><tr>
            <td>serverBytesReceived</td>
            <td>Number of bytes the connector has received</td>
        </tr><tr>
            <td>serverBytesSent</td>
            <td>Number of bytes the connector has sent</td>
        </tr><tr>
            <td>serverTimeToFirstByte</td>
            <td>Time to first byte of response body is sent</td>
        </tr><tr>
            <td>serverTotalSuccessfulResponseLatency</td>
            <td>Time to complete successful responses</td>
        </tr><tr>
            <td>serverTotalFailedResponseLatency</td>
            <td>Time to complete failed responses</td>
        </tr>
    </tbody>
</table>
