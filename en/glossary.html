---
# Copyright Yahoo. Licensed under the terms of the Apache 2.0 license. See LICENSE in the project root.
title: "Glossary"
---

<style> /* temp style while developing */
li {
    margin-top: 20px;
}
li > ul > li {
    margin-top: 0;
}
</style>


<p>
  Glossary of both Vespa-specific terminology, also including general terms useful in this context.
</p>
<hr />

<ul>
  <li>
    <p id="application"><strong>Application</strong></p>
    <p>
      The unit of deployment and management.
      Can contain any number of clusters and schemas etc., but all deployed together.
    </p>
  </li>
  <li>
    <p id="cluster"><strong>Cluster</strong></p>
    <p>
      A set of homogenous nodes which all perform the same task.
      Vespa has two types: Container clusters are stateless, and content clusters store and process the data.
    </p>
  </li>
  <li>
    <p id="component"><strong>Component</strong></p>
    <p>
      Components extend a base class from the Container code module,
      and some are <a href="components/chained-components.html">Chained</a> for execution.
      The main available component types are:
    </p>
    <ul>
      <li>Processors</li>
      <li><a href="#searcher">Searchers</a></li>
      <li><a href="#document-processor">Document Processors</a></li>
      <li>Search Result Renderers</li>
      <li>Provider Components</li>
    </ul>
  </li>
  <li>
    <p id="container"><strong>Container</strong></p>
    <p>
      Vespa's Java container, hosts all application components as well as the stateless logic of Vespa itself.
      Read more in <a href="jdisc/index.html">Container</a>.
    </p>
  </li>
  <li>
    <p id="document"><strong>Document</strong></p>
    <p>
      Vespa models data as documents.
      A document has a string identifier, set by the application, unique across all documents.
      A document is a set of key-value pairs.
      A document has a <a href="#schema">Schema</a>.
      Read more in <a href="documents.html">Documents</a>.
    </p>
  </li>
  <li>
    <p id="document-processor"><strong>Document Processor</strong></p>
    <p>
      Document processing is a framework to create chains of configurable <a href="#component">Components</a>,
      that read and modify document operations.
      A Document Processor uses <code>getFieldValue()</code> and <code>setFieldValue()</code> to process fields,
      alternatively using generated code from <a href="concrete-documents.html">Concrete Documents</a>.
    </p>
  </li>
  <li>
    <p id="document-type"><strong>Document type</strong></p>
    <p>
      The data type part of a <a href="#schema">Schema</a> - a collection of fields.
    </p>
  </li>
  <li>
    <p id="field"><strong>Field</strong></p>
    <p>
      Documents have <a href="schemas.html#field">Fields</a>.
      A field has a type, and a field contained in a document can be written to, read from and queried.
      A field can also be generated (i.e. a synthetic field) -
      in this case, the field definition is outside the document.
      A field can be single value, like a string, or multivalue, like an array of strings.
    </p>
  </li>
  <li>
    <p id="garbage-collection"><strong>Garbage Collection</strong></p>
    <p>
      Use a <a href="reference/services-content.html#document.selection">Document Selection</a>
      to <a href="documents.html#document-expiry">auto-expire</a> documents by time or any other criterion.
    </p>
  </li>
  <li>
    <p id="namespace"><strong>Namespace</strong></p>
    <p>
      A segment of <a href="#document">Document IDs</a>
      which helps you generate unique ids also if you have multiple sources of unique values.
      Namespace can be used to <a href="#visit">Visit</a> a subspace of the corpus.
      <!-- ToDo: Add to readme in https://github.com/vespa-cloud/vespa-documentation-search and link there
                 for an example of how to use namespace to partition the corpus -->
    </p>
  </li>
  <li>
    <p id="parent-child"><strong>Parent / Child</strong></p>
    <p>
      Using document references, documents can have <a href="parent-child.html">parent/child</a> relationships.
      Use this to join data by importing fields from parent documents.
      Parent documents are replicated to all nodes in the cluster.
    </p>
  </li>
  <li>
    <p id="query"><strong>Query</strong></p>
    <p>
      Use the <a href="query-api.html">Query API</a> to query the corpus.
      Queries are written in <a href="reference/query-language-reference.html">YQL</a>,
      or can be created programmatically in a <a href="#searcher">Searcher</a>.
      Configure query execution in a <a href="query-profiles.html">Query Profile</a>.
    </p>
  </li>
  <li>
    <p id="ranking"><strong>Ranking</strong></p>
    <p>
      Ranking is where Vespa does computing, or inference over documents.
      The computations to be done are expressed in functions called
      <a href="ranking-expressions-features.html#ranking-expressions">Ranking Expressions</a>,
      bundled into <a href="ranking.html#rank-profiles">Rank Profiles</a> defined in a <a href="#schema">Schema</a>.
      These can range from simple math expressions combining some rank features,
      to tensor expressions or large machine-learned models.
      Ranking can be single- or <a href="phased-ranking.html">multiphased</a>.
    </p>
  </li>
  <li>
    <p id="schema"><strong>Schema</strong></p>
    <p>
      A description of a particular type of data and how to process/rank it.
      See the <a href="schemas.html">Schema guide</a>.
    </p>
  </li>
  <li>
    <p id="searcher"><strong>Searcher</strong></p>
    <p>
      A searcher is a <a href="#component">Component</a> - usually deployed as part of an OSGi bundle.
      All Searchers must implement a single method <code>search(query)</code>.
      Developers implement application query logic in Searchers.
    </p>
  </li>
  <li>
    <p id="tensor"><strong>Tensor</strong></p>
    <p>
      A <a href="tensor-user-guide.html">Tensor</a> is a data structure which generalizes scalars, vectors and matrices
      to any number of dimensions:
      A scalar is a tensor of rank 0, a vector is a tensor of rank 1, a matrix is a tensor of rank 2.
      Tensors consist of a set of scalar valued cells, with each cell having a unique address.
      A cell's address is specified by its index or label in all the dimensions of that tensor.
      The number of dimensions in a tensor is the rank of the tensor,
      each dimension can be either mapped or indexed.
    </p>
  </li>
  <li>
    <p id="visit"><strong>Visit</strong></p>
    <p>
      <a href="content/visiting.html">Visit</a> is a feature to efficiently get or process a set of / all documents,
      identified by a <a href="reference/document-select-language.html">Document Selection Expression</a>.
      Visit iterates over all, or a set of, buckets and sends documents to a (set of) targets.
    </p>
  </li>
</ul>

<!-- ToDo: (some will be combined into larger units):
tenant
instance
deployment
config server
content node
control plane
data plane
docker / podman / container
node / host
service
grouping
partial update
attribute
elasticity
boolean search / predicate
application package
federation
embedding
nearest neighbor / HNSW
document summary
indexing
index
linguistics
onnx / tensorflow
kubernetes / EC2
AWS / GCP / self-hosted
multinode
model
tensor
-->
